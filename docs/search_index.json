[["index.html", "Readings for MTH250 - Data Wrangling Preface Package Needs", " Readings for MTH250 - Data Wrangling Derek H. Ogle 27 Jul 2021 Preface XXX However, there are likely still errors or descriptions that dont make sense. Please feel free to ask questions or post errors on the appropriate channel of the course MS Team. The book highlights definitions and tips in special boxes. Definition: This is a definition. This is a tip. R Code and results are also shown in special boxes. Code in the R box can be copied verbatim from the box with the icon that appears when you hover over the upper right corner of the code box. dat &lt;- c(3,4,5,2,8) mean(dat) #R&gt; [1] 4.4 The material presented in this book can be challenging to master. Please dont hesitate to ask me questions as you have them! Package Needs library(tidyverse) "],["preparation.html", "Module 1 Preparation", " Module 1 Preparation XXX "],["data-structures.html", "Module 2 Data Structures 2.1 Vectors 2.2 Data Classes 2.3 Data Frames 2.4 Tidy Data", " Module 2 Data Structures 2.1 Vectors The vector is the primary unit for storing data in R. You can think of a vector as a set of similar items. Vectors are created in R by combining or concatenating together the individual items into a single set with c(). For example, the code below creates a vector of county names stored in an object called cn (perhaps, short for county names). cn &lt;- c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;) Similarly the code below creates a vector of the population size in four counties stored in an object called pop. pop &lt;- c(15512,15056,43164,5687) Vector: The variable thought to depend upon, be explained by, or be predicted by other variables.   Individual items in a vector can be accessed by following the vectors object name with square brackets that contain the numeric position of the item. For example, the second county in cn and the third population size in pop are extracted below. cn[2] #R&gt; [1] &quot;Bayfield&quot; pop[3] #R&gt; [1] 43164 Multiple items can be accessed by combining their position indices into a vector. cn[c(2,3)] #R&gt; [1] &quot;Bayfield&quot; &quot;Douglas&quot; 2.2 Data Classes Vectors must contain the same type or class of items. There are four main classes of data in R. numeric: Numbers that may have decimals; e.g., 12.3. integer: Numbers that do not have decimals; e.g., 12. character: Words; e.g., Bayfield. logical: Logical that must be either TRUE or FALSE. The primary difference between numeric and integer classes is how the data are stored in memory. For most of our purposes this will be irrelevant, so there is no practical difference between these two classes for our work. However, integer values are entered into a vector by appending the value with an L. nabors &lt;- c(4L,3L,3L,3L) The values in a logical vector must be either TRUE or FALSE. Make sure to note that both of these values are in all capital letters. cheqbay &lt;- c(TRUE,TRUE,FALSE,FALSE)   The class (i.e., type) of data in a vector is found with class(). class(cn) #R&gt; [1] &quot;character&quot; class(pop) #R&gt; [1] &quot;numeric&quot; class(nabors) #R&gt; [1] &quot;integer&quot; class(cheqbay) #R&gt; [1] &quot;logical&quot; A factor is a special class of data where character items are specifically classified as representing groups or levels of items. A vector can be converted to a factor class with factor(). fcn &lt;- factor(cn) fcn #R&gt; [1] Ashland Bayfield Douglas Iron #R&gt; Levels: Ashland Bayfield Douglas Iron class(fcn) #R&gt; [1] &quot;factor&quot; Factors have useful properties that will be discussed in more detail in subsequent modules. As stated above, a vector should consist of items of the same class type. For example, this code does not make sense in most instances. huh &lt;- c(&quot;Ashland&quot;,15512,TRUE,3.65) However, this will not produce an error, though it likely will not be what you want it to be. For example, examine the class of this object. class(huh) #R&gt; [1] &quot;character&quot; R uses hierarchical rules to assign a class for these odd situations. Rather than focusing on these rules it is more beneficial to remember that each vector should be of the same class type. Items in vectors should all be the same class type. 2.3 Data Frames Vectors are useful for small numbers of items that have a single purpose. However, a data frame is more useful if you have multiple types of items (e.g., variables) recorded on a large number of individuals. Here we explore small data frames; larger data frames will be imported from external data sources in Module 3. A data frame is a rectangular data structure where columns are vectors of the same class that represent variables recorded on individuals which are represented in rows. Simple data frames can be constructed with data.frame() with named arguments set equal to vectors of data. For example, the following code produces a data frame object called counties that has three variables called name, pop, and party. counties &lt;- data.frame(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) Type the name of the data frame object to see its contents. counties #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep Columns of data frames correspond to variables whereas rows correspond to individuals. Use str() to examine the structure of the data frame object, which will show that the object is a data.frame, show the number of individuals (label as obs for observations) and variables, and show the name of each column/variable along with its class type abbreviation and a snapshot of the first few items in each row. str(counties) #R&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #R&gt; $ name : chr &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; ... #R&gt; $ pop : num 15512 15056 43164 5687 16746 #R&gt; $ party: chr &quot;Dem&quot; &quot;Dem&quot; &quot;Dem&quot; &quot;Rep&quot; ... As data frames are rectangular, individual items are accessed by using both the row and column positions within square brackets after the data frame object name. counties[1,2] # first row, second column #R&gt; [1] 15512 counties[3,1] # third row, first column #R&gt; [1] &quot;Douglas&quot; Entire rows or columns are accessed by providing the numerical position of the row or column and leaving the other indice blank. counties[1,] # First row #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem counties[,1] # First column #R&gt; [1] &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; &quot;Sawyer&quot; Note that choosing rows or more than one column will return a data frame as it will likely have data of different classes. class(counties[1,]) # one row is a data frame #R&gt; [1] &quot;data.frame&quot; class(counties[,c(1,2)]) # two columns is a data frame #R&gt; [1] &quot;data.frame&quot; However, choosing one column will return a vector of items all of the same class. class(counties[,1]) # one column is a vector #R&gt; [1] &quot;character&quot; As columns are named we can also use the name to access a specific column. counties[,&quot;pop&quot;] #R&gt; [1] 15512 15056 43164 5687 16746 This same column can be accessed by separating the data frame object name from the column name with a $. counties$pop #R&gt; [1] 15512 15056 43164 5687 16746 Again a column is simply a vector so you access single items in this vector in the usual way. counties$pop[3] #R&gt; [1] 43164 A $ is only used to separate a data frame name from the variable name within that data frame. 2.3.1 Tibbles Tibbles are a special form of data frame that was introduced as part of the tidyverse. Tibbles are created using tibble() in the same way that we used data.frame() previously. counties2 &lt;- tibble(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) For most of our purposes a tibble will behave exactly as a data frame. For example, counties2 #R&gt; # A tibble: 5 x 3 #R&gt; name pop party #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep counties2$pop #R&gt; [1] 15512 15056 43164 5687 16746 There are, however, differences between tibbles and data frames as described in this introduction to tibbles. The primary difference that you will notice in this course is that when you examine the contents of a tibble with a larger number of rows, columns, or both. For example the code below converts a data frame from the FSA package into a tibble. tibex &lt;- as_tibble(FSA::WhitefishLC) However, when you try to display the data in this tibble you can see that only first 10 rows and as many columns as will fit on the width of your display are shown. In this case, 141 rows and one variable are not shown as seen in the note at the bottom. tibex #R&gt; # A tibble: 151 x 11 #R&gt; fishID tl scale1 scale2 scaleC finray1 finray2 finrayC otolith1 otolith2 #R&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #R&gt; 1 1 345 3 3 3 3 3 3 3 3 #R&gt; 2 2 334 4 3 4 3 3 3 3 3 #R&gt; 3 3 348 7 5 6 3 3 3 3 3 #R&gt; 4 4 300 4 3 4 3 2 3 3 3 #R&gt; 5 5 330 3 3 3 4 3 4 3 3 #R&gt; 6 6 316 4 4 4 2 3 3 6 5 #R&gt; 7 7 508 6 7 7 6 6 6 9 10 #R&gt; 8 8 475 4 5 5 9 9 9 11 12 #R&gt; 9 9 340 3 3 3 2 3 3 3 4 #R&gt; 10 10 173 1 1 1 2 1 1 1 1 #R&gt; # ... with 141 more rows, and 1 more variable: otolithC &lt;int&gt; We will encounter tibbles in subsequent modules as some tidyverse functions return tibbles by default. A tibble can be converted to a data frame with as.data.frame(). 2.4 Tidy Data Tidy Data was a term introduced here in 2011 to describe a strict data organization that leads to consistency and efficiencies in data analyses. Tidy data is described in more detail here. Data can be organized in different ways. For example, below is the simple data frame from Section 2.3. #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep However, these same data could be organized as below (among other possible organizations). #R&gt; county variable value #R&gt; 1 Ashland pop 15512 #R&gt; 2 Ashland party Dem #R&gt; 3 Bayfield pop 15056 #R&gt; 4 Bayfield party Dem #R&gt; 5 Douglas pop 43164 #R&gt; 6 Douglas party Dem #R&gt; 7 Iron pop 5687 #R&gt; 8 Iron party Rep #R&gt; 9 Sawyer pop 16746 #R&gt; 10 Sawyer party Rep This second data frame is not tidy and is much more difficult to use. Tidy data frames follow three simple rules (Figure 2.1): Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. The original data frame above is tidy.   Figure 2.1: Schematic illustration the structure of tidy data (from Ocean Health Index Team)   A common challenge when entering data in a tidy format occurs when data is recorded on individuals in separate groups. For example, the following data are methyl mercury levels recorded in mussels from two locations labeled as impacted and reference. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 In this case, you must realize that one observation is a methyl mercury measurement on a mussel AND to which group the mussel belongs. Thus, each observation results in the recording of two variables. For example, the first mussel had a methyl mercury level of 0.011 AND it was at the impacted site. With this understanding these data are entered in a tidy format as follows. mussels &lt;- tibble(loc=c(&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;), merc=c(0.011,0.054,0.056,0.095,0.051,0.077, 0.031,0.040,0.029,0.066,0.018,0.042,0.044)) mussels #R&gt; # A tibble: 13 x 2 #R&gt; loc merc #R&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 impacted 0.011 #R&gt; 2 impacted 0.054 #R&gt; 3 impacted 0.056 #R&gt; 4 impacted 0.095 #R&gt; 5 impacted 0.051 #R&gt; 6 impacted 0.077 #R&gt; 7 reference 0.031 #R&gt; 8 reference 0.04 #R&gt; 9 reference 0.029 #R&gt; 10 reference 0.066 #R&gt; 11 reference 0.018 #R&gt; 12 reference 0.042 #R&gt; 13 reference 0.044 Tidy data will facilitate data wrangling in subsequent modules and data analysis and graphing in other courses. "],["read-external-data-files.html", "Module 3 Read External Data Files 3.1 Entering Data 3.2 Saving the External File 3.3 Reading the External File", " Module 3 Read External Data Files Most realistic data has more than a few individuals and is, thus, not easily entered using data.frame() or tibble() as shown in Section 2.3. Rather these data are often entered and stored in a spreadsheet or database that is external to R and, thus, needs to be read or loaded into R. This module describes how data should be entered into a spreadsheet and then how that data is read into R. 3.1 Entering Data Tidy data (see Section 2.4) is often read into a spreadsheet program such as Microsoft Excel or Google Sheets. The spreadsheet should be organized with variables in columns and individuals in rows, with the exception that the first row should contain variable names. The example spreadsheet below shows the length (cm), weight (kg), and capture location data for a small sample of Black Bears.   Variable names should NOT contain spaces. For example, dont use total length or length (cm). If you feel the need to have longer variable names, then separate the parts with a period (e.g., length.cm) or an underscore (e.g., length_cm). Variable names can NOT start with numbers or contain special characters such as ~, ! &amp;, @, etc. Furthermore, numerical measurements should NOT include units (e.g., dont use 7 cm). Finally, for categorical data, make sure that all categories are consistent (e.g., do not use both bayfield and Bayfield). When entering data make sure to follow the three rules of tidy data (see Section 2.4). For example, the following data are methyl mercury levels recorded in mussels captured from impacted and reference locations. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 As described in Section 2.4, one observation (i.e., row) is a methyl mercury measurement on a mussel AND which group the mussel belongs. The rules for tidy data dictate two columns (one for each of the two variables recorded) and 13 rows (one for each obseration of a mussel). format as follows. Thus, these data would be entered into the spreadsheet as shown below.   3.2 Saving the External File The spreadsheet may be saved in the format of the spreadsheet program (e.g., as an Excel file) to be read into R. However, it is also common to save the file as a comma separated values (CSV) file to be read into R. The advantage of a CSV file is that these files are small and, because they do not require any special software (e.g., Excel) to read, they are very likely to always be able to be read into R. 3.2.1 Excel An Excel worksheet is saved as a CSV file by selecting the File..Save As menu item, which will produce the dialog box below. In this dialog box, change Save as type to CSV (Comma delimited),1, provide a file name (do not put any periods in the name), select a location to save the file (this should be the same location as your assignment template file), and press Save. Two warning dialog boxes may then appear  select OK for the first and YES for the second. You can now close the spreadsheet file.2 3.2.2 Google Sheets A Google Sheet can be made available as a CSV file with the following steps by selecting the File menu, Share submenu, and Publish to web submenu. In the ensuing dialog box, change Entire Document to name of the sheet you want to publish and Web Page to Comma-separated values (.csv) under the Link tab. Then press the Publish button and press OK when asked to confirm publishing. Finally, select and copy (CTRL-C or CMD-C) the entire link shown in the box above. This link will be used as described in the next section. 3.3 Reading the External File 3.3.1 CSV Files CSV files may be read with read.csv() from base R or read_csv() from tidyverse. For most of our applications there will be little functional difference between these two functions. However, read_csv() is faster than read.csv() and can be a little smarter about the way it imports certain columns.3 In addition, it is a bit more transparent about what it is doing. For those reasons, we will use read_csv() in this course. An object saved from read_csv() will be a tibble. The first argument to read_csv() is the filename. This file must exist in your working directory, include be a partial path relative to your working directory or a full path to the file, or be a valid URL. For example, the code below reads Bears.csv from the data folder in my working directory and stores the result in the bears object. Here, I used file.path() to combine the folder names in the partial path with the filename because file.path() creates at path that will be correct for your operating system.4 bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The filename argument could also be the link to the published Google Sheet (from above). bears &lt;- read_csv(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vQaxD9tvwL29MydISlYw4bVXrw6-rvkEbT_2qFGxw7HuYX6M3h83aIYT4eZ-mrrEfJf8y5Q8p1Rkn4Z/pub?gid=522647677&amp;single=true&amp;output=csv&quot;) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The URL does not have to be from the published Google Sheet. For example, the following reads a CSV from this page that lists information about every player who has played in the National Basketball Association (NBA). players &lt;- read_csv(&quot;https://sports-statistics.com/database/basketball-data/nba/NBA-playerlist.csv&quot;) players #R&gt; # A tibble: 4,393 x 15 #R&gt; X1 DISPLAY_FIRST_LAST DISPLAY_LAST_COMMA_FIRST FROM_YEAR GAMES_PLAYED_FL~ #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 0 Alaa Abdelnaby Abdelnaby, Alaa 1990 Y #R&gt; 2 1 Zaid Abdul-Aziz Abdul-Aziz, Zaid 1968 Y #R&gt; 3 2 Kareem Abdul-Jabbar Abdul-Jabbar, Kareem 1969 Y #R&gt; 4 3 Mahmoud Abdul-Rauf Abdul-Rauf, Mahmoud 1990 Y #R&gt; 5 4 Tariq Abdul-Wahad Abdul-Wahad, Tariq 1997 Y #R&gt; 6 5 Shareef Abdur-Rahim Abdur-Rahim, Shareef 1996 Y #R&gt; 7 6 Tom Abernethy Abernethy, Tom 1976 Y #R&gt; 8 7 Forest Able Able, Forest 1956 Y #R&gt; 9 8 John Abramovic Abramovic, John 1946 Y #R&gt; 10 9 Alex Abrines Abrines, Alex 2016 Y #R&gt; # ... with 4,383 more rows, and 10 more variables: #R&gt; # OTHERLEAGUE_EXPERIENCE_CH &lt;chr&gt;, PERSON_ID &lt;dbl&gt;, PLAYERCODE &lt;chr&gt;, #R&gt; # ROSTERSTATUS &lt;dbl&gt;, TEAM_ABBREVIATION &lt;chr&gt;, TEAM_CITY &lt;chr&gt;, #R&gt; # TEAM_CODE &lt;chr&gt;, TEAM_ID &lt;dbl&gt;, TEAM_NAME &lt;chr&gt;, TO_YEAR &lt;dbl&gt;   The read_csv() function provides a variety of options that will help you correctly load CSV files that may be quirky in some respects. Use skip.lines= to skip, for example, the first two lines in a CSV file that do not contain data (perhaps they hold comments). tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_SkipLines.csv&quot;),skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Alternatively, use comment= to identify leading characters that identify lines in the data file that are comments and should not be read as data. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Comment.csv&quot;),comment=&quot;#&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Often data may be missing. By default, R treats NA in the data frame as missing data. If all missing data is coded with NA then read_csv() will handle this properly. For example, note the NAs in the second and eighth rows below. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing1.csv&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; However, some researcher may denote missing data with other codes. For example, the data file read below used - denote missing data. In cases like this, use na= to dictate which codes should be missing and converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing2.csv&quot;),na=&quot;-&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; In other instances, the research may have sloppily used multiple codes for missing data. In these instances, set na= to a vector of all codes to be converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing3.csv&quot;),na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.2 Excel Files Some researchers prefer to save data entered in Excel as an Excel workbook rather than a CSV file. The main argument here is that saving to a CSV often results in two files  an Excel workbook file and a CSV file. It is generally bad practice to have your data in two files as you may update the Excel file and forget to save it to the CSV file or you may update the CSV file and forget to also update the Excel file. Regardless of the reason, data can generally be read from an Excel file into R. The read_excel() function from the readxl package provides a coherent process for reading data from an Excel workbook. The first argument to read_excel() is the name of the Excel file, possibly with path information. By default read_excel() reads the first sheet in the Excel workbook. The example below reads the first sheet of the DataExamples.xlsx workbook in the data folder.5 tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Data on specific sheets can be read by including the sheet name in sheet=. Additionally, lines at the top of the sheet can be skipped with skip= as described for read_csv(). For example, the code below reads the data after the first two lines in the Bears_SkipLines worksheet in the same Excel workbook. tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_SkipLines&quot;,skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Missing data is handled exactly as described for read_csv(). tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_Missing3&quot;,na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   In general, read_excel() works best if the data are arranged rectangularly starting in cell A1. However, read_excel() can handle different organizations of data in the worksheet as described here. Researchers may also use multiple header rows in their Excel worksheet; e.g., variables names in the first row, variable units in the second row. This provides a strategy for reading data arranged in such a way. The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.3 Google Sheets It is also possible to read a file directly from Google Sheets using functions in the googlesheets4 package as described here. Using this package to read directly from Google Sheets requires you to authorize R to access your Google Sheets. 3.3.4 Other Formats Data may be stored in other, less common formats. A rew examples of functions to read these other formats are listed below. read_csv2() (from tidyverse) for fields separated by semi-colons (rather than commas) as is common in Europe. read_tsv() (from tidyverse) for fields separated by tabs (rather than commas). read_fwf() (from tidyverse) for fields that are a fixed width. read_sav() (from haven) for .sav files from SPSS. read_sas() (from haven) for .sas7bdat and .sas7bcat files from SAS. read_dta() (from haven) for .dta files from Stata. There are several choices for CSV files here; do NOT choose the one with UTF-8 in the name. You may be asked to save changes  you should say No. How read_csv() identifies the class of data in a column is described here Windows and Mac OS handle paths differently; this function avoids that complication. I use the readxl::read_excel() construct here rather than loading the readxl package and then simply using read_excel() because this is the only function that I will use from readxl. Thus, I am not loading unneeded functions into my work environment. "],["relational-data.html", "Module 4 Relational Data 4.1 Join Concepts 4.2 Joins in R 4.3 Examples With Context", " Module 4 Relational Data Some situations will have multiple data frames with related data. A particular analysis may require combining these data frames into a single data frame. If the data in the separate data frames are connected by a key variable then the data are said to be relational  i.e., they relate to each other through a common variable (or variables). As an example a college may have the following four data frames with respect to its students. Personal information (hometown, age, etc.) Financial aid information (family income, Pell Grant aid amount, etc.) Academic information (standing, major, gpa, etc.) Current course information (i.e., which courses a students is registered for) Each of these data frames would also contain a student ID variable so that a students personal information can be connect with the students financial aid, academic, or course information. This student ID variable is the key variable for these relational data frames. Data from related data frames can be joined in a variety of ways. This module will explain several types of joins and how to accomplish those joins in R. 4.1 Join Concepts To illustrate the various joins, suppose that a simple data frame x exists that has an id key variable and a val1 measurement variable.6 id val1 101 x1 102 x2 102 x3 103 x4 Further suppose that a second data frame y has the same id key variable and different val2 and val3 measurement variables.7 id val2 val3 101 y1 z1 102 y2 z2 104 y3 z3 104 y4 z4 It is instructive when learning about joins to visualize all combinations of observations in the two data frames.8 As some key variable values may be missing in the data frames we also consider combinations with a missing key variable value (and the measurement variables set to NA), All combinations of the rows in x and y with the missing key values are shown on the left for each join type in the subsections below. 4.1.1 Inner Join An inner join is the simplest join. It returns values from both data frames where the key variable(s) match in both data frames. In our simple data frames an inner join returns the rows from all combinations of rows (see left below) where the id variables (i.e., colors) from x and y match (see center below). The final result is these rows with the duplicated id key variable removed (see right below). All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for inner join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final inner join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 Inner Join: Rows from both data frames where the key variable columns match. 4.1.2 Left Join A left join returns the same rows as an inner join (i.e., all rows where the key variables match) AND all rows from the first data frame that dont have a key variable match in the second data frame. The values for the variables in the second data frame for key values in the first data frame without a match are replaced with NAs. So, a left join will include rows for all key variables from the first data frame, but only rows from the second data frame that had a key variable match with the first data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for left join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final left join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA Left Join: All rows from the first data frame with variables from the second data frame where the key variable columns match (NA otherwise). 4.1.3 Right Join A right join works just like a left join except that the result will include all rows from the second data frame that dont have a key variable match in the first data frame. A right join can also be accomplished with a left join by reversing the order of the two data frames. Right Join: All rows from the second data frame with variables from the first data frame where the key variable columns match (NA otherwise). 4.1.4 Full Join A full join returns the same rows as an inner join (i.e., all rows where the key variable match) AND all rows from each data frame that dont have a key variable match in the other data frame. So a full join will include rows for all key variables from both data frames. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for full join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final full join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA 104 NA y3 z3 104 NA y4 z4 Full Join: All rows from both data frame with variables from the other data frame where the key variable columns match (NA otherwise). 4.1.5 Semi Join In a semi join only values from the first data frame that have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows that had a key variable match in the second data frame. This is the same result as an inner join but without including the variables from the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for semi join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final semi join result id val1 101 x1 102 x2 102 x3 Semi Join: All variables from the first data frame for rows where the key variable column has a match in the second data frame. 4.1.6 Anti Join In an anti join only values from the first data frame that DO NOT have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows without a key variable match in the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for anti join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final anti join result id val1 103 x4 Anti Join: All variables from the first data frame for rows where the key variable column does NOT have a match in the second data frame.   4.2 Joins in R Performing the joins described in the previous section is straightforward with dplyr (part of the tidyverse) using, conveniently enough, inner_join(), left_join(), right_join(), full_join(), semi_join(), and anti_join(). The first two arguments to each of these functions are the two data frames to join. In addition, the name of the key variable should be given, in quotes, to by=.9 The two data frames used in the previous section are created below as objects in R. x &lt;- data.frame(id=c(101,102,102,103),val1=paste0(&quot;x&quot;,1:4)) x #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 #R&gt; 4 103 x4 y &lt;- data.frame(id=c(101,102,104,104),val2=paste0(&quot;y&quot;,1:4),val3=paste0(&quot;z&quot;,1:4)) y #R&gt; id val2 val3 #R&gt; 1 101 y1 z1 #R&gt; 2 102 y2 z2 #R&gt; 3 104 y3 z3 #R&gt; 4 104 y4 z4   The six joins discussed in the previous section are completed below. You should compare the results here to the visual results above. ij &lt;- inner_join(x,y,by=&quot;id&quot;) ij #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 lj &lt;- left_join(x,y,by=&quot;id&quot;) lj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; rj &lt;- right_join(x,y,by=&quot;id&quot;) rj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 104 &lt;NA&gt; y3 z3 #R&gt; 5 104 &lt;NA&gt; y4 z4 rj2 &lt;- left_join(y,x,by=&quot;id&quot;) # right_join as left_join with x &amp; y reversed rj2 #R&gt; id val2 val3 val1 #R&gt; 1 101 y1 z1 x1 #R&gt; 2 102 y2 z2 x2 #R&gt; 3 102 y2 z2 x3 #R&gt; 4 104 y3 z3 &lt;NA&gt; #R&gt; 5 104 y4 z4 &lt;NA&gt; fj &lt;- full_join(x,y,by=&quot;id&quot;) fj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; #R&gt; 5 104 &lt;NA&gt; y3 z3 #R&gt; 6 104 &lt;NA&gt; y4 z4 sj &lt;- semi_join(x,y,by=&quot;id&quot;) sj #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 aj &lt;- anti_join(x,y,by=&quot;id&quot;) aj #R&gt; id val1 #R&gt; 1 103 x4   4.3 Examples With Context The following examples demonstrate different types of joins within fictitious, but realistic, contexts. Please examine each data frame and the joined results carefully to help further understand what each type of join does. 4.3.1 Student Data (One-to-One) In large institutions or in complicated data environments, data about specific individuals may be housed in a variety of departments each of which maintains its own database. Preferably these data sources can be related via a primary key variable, such as a unique student ID number. As an example, suppose that a colleges admissions office maintains a database of personal information about every student at the college. For example it might look like that below for a fictitious five students. personal &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), first_nm=c(&quot;Rolando&quot;,&quot;Catherine&quot;,&quot;James&quot;,&quot;Rachel&quot;,&quot;Esteban&quot;), last_nm=c(&quot;Blackman&quot;,&quot;Johnson&quot;,&quot;Carmichael&quot;,&quot;Brown&quot;,&quot;Perez&quot;), hometown=c(&quot;Windsor&quot;,&quot;Eden Prairie&quot;,&quot;Marion&quot;,&quot;Milwaukee&quot;,&quot;El Paso&quot;), homestate=c(&quot;MI&quot;,&quot;MN&quot;,&quot;IA&quot;,&quot;WI&quot;,&quot;TX&quot;)) personal #R&gt; studentID first_nm last_nm hometown homestate #R&gt; 1 34535 Rolando Blackman Windsor MI #R&gt; 2 45423 Catherine Johnson Eden Prairie MN #R&gt; 3 73424 James Carmichael Marion IA #R&gt; 4 89874 Rachel Brown Milwaukee WI #R&gt; 5 98222 Esteban Perez El Paso TX In addition the financial aid office may have a database of financial aid information. finaid &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), income_cat=c(4,5,3,2,3), pell_elig=c(TRUE,FALSE,TRUE,TRUE,TRUE), work_study=c(TRUE,FALSE,FALSE,FALSE,TRUE)) finaid #R&gt; studentID income_cat pell_elig work_study #R&gt; 1 34535 4 TRUE TRUE #R&gt; 2 45423 5 FALSE FALSE #R&gt; 3 73424 3 TRUE FALSE #R&gt; 4 89874 2 TRUE FALSE #R&gt; 5 98222 3 TRUE TRUE Furthermore the registrars office has a database of academic information. academics &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), standing=c(&quot;FY&quot;,&quot;FY&quot;,&quot;SO&quot;,&quot;SR&quot;,&quot;JR&quot;), major=c(&quot;undecided&quot;,&quot;NRS&quot;,&quot;Biology&quot;,&quot;SCD&quot;,&quot;SCD&quot;), cum_gpa=c(0,0,3.12,3.67,2.89)) academics #R&gt; studentID standing major cum_gpa #R&gt; 1 34535 FY undecided 0.00 #R&gt; 2 45423 FY NRS 0.00 #R&gt; 3 73424 SO Biology 3.12 #R&gt; 4 89874 SR SCD 3.67 #R&gt; 5 98222 JR SCD 2.89 Note how each of these databases has the studentID variable that will serve as the key variable to connect each students information across each of the databases. These databases form what is called a one-to-one relationship because as each observation record in each database can be connected to one and only one observation record in the other databases. In this example, each database would ideally have an entry for every student. These data frames can generally be joined with inner, left, or right joins depending on the purpose. For example, an institutional researcher may want to examine whether student gpa differed between students that were eligible for a Pell Grant or not. In this case, the researcher would join the finaid and academics data frames so that the pell_elig and cum_gpa variables would be in one data frame. tmp &lt;- inner_join(finaid,academics,by=&quot;studentID&quot;) tmp #R&gt; studentID income_cat pell_elig work_study standing major cum_gpa #R&gt; 1 34535 4 TRUE TRUE FY undecided 0.00 #R&gt; 2 45423 5 FALSE FALSE FY NRS 0.00 #R&gt; 3 73424 3 TRUE FALSE SO Biology 3.12 #R&gt; 4 89874 2 TRUE FALSE SR SCD 3.67 #R&gt; 5 98222 3 TRUE TRUE JR SCD 2.89 An inner join was used here because the researcher only wants to include students that are in both databases (i.e., would likely have an entry for both pell_elig and cum_gpa). Note, however, that a left join or a right join would accomplish the same task as long as both databases had entries for every student (i.e., the databases have the same set of students).   Further suppose that academic advisors would like to have the students names attached to these records so that they could reach out to students who could use some help academically. tmp &lt;- inner_join(personal,tmp,by=&quot;studentID&quot;) tmp #R&gt; studentID first_nm last_nm hometown homestate income_cat pell_elig #R&gt; 1 34535 Rolando Blackman Windsor MI 4 TRUE #R&gt; 2 45423 Catherine Johnson Eden Prairie MN 5 FALSE #R&gt; 3 73424 James Carmichael Marion IA 3 TRUE #R&gt; 4 89874 Rachel Brown Milwaukee WI 2 TRUE #R&gt; 5 98222 Esteban Perez El Paso TX 3 TRUE #R&gt; work_study standing major cum_gpa #R&gt; 1 TRUE FY undecided 0.00 #R&gt; 2 FALSE FY NRS 0.00 #R&gt; 3 FALSE SO Biology 3.12 #R&gt; 4 FALSE SR SCD 3.67 #R&gt; 5 TRUE JR SCD 2.89   Continuing with this example, suppose that the registrars office also maintains a database that contains each students current class schedule. schedules &lt;- tibble(studentID=c(34535,34535,34535,34535, 45423,45423,45423,45423,45423, 73424,73424,73424,73424, 89874,89874,89874, 98222,98222,98222,98222), course=c(&quot;MTH107&quot;,&quot;BIO115&quot;,&quot;CHM110&quot;,&quot;IDS101&quot;, &quot;SCD110&quot;,&quot;PSY110&quot;,&quot;MTH140&quot;,&quot;OED212&quot;,&quot;IDS101&quot;, &quot;BIO234&quot;,&quot;CHM220&quot;,&quot;BIO370&quot;,&quot;SCD110&quot;, &quot;SCD440&quot;,&quot;PSY370&quot;,&quot;IDS490&quot;, &quot;SCD440&quot;,&quot;SCD330&quot;,&quot;SOC480&quot;,&quot;ART220&quot;)) schedules #R&gt; # A tibble: 20 x 2 #R&gt; studentID course #R&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 #R&gt; 2 34535 BIO115 #R&gt; 3 34535 CHM110 #R&gt; 4 34535 IDS101 #R&gt; 5 45423 SCD110 #R&gt; 6 45423 PSY110 #R&gt; 7 45423 MTH140 #R&gt; 8 45423 OED212 #R&gt; 9 45423 IDS101 #R&gt; 10 73424 BIO234 #R&gt; 11 73424 CHM220 #R&gt; 12 73424 BIO370 #R&gt; 13 73424 SCD110 #R&gt; 14 89874 SCD440 #R&gt; 15 89874 PSY370 #R&gt; 16 89874 IDS490 #R&gt; 17 98222 SCD440 #R&gt; 18 98222 SCD330 #R&gt; 19 98222 SOC480 #R&gt; 20 98222 ART220 The registrars office also maintains a database of information about every course taught at the college. A partial example of such a database is shown below.10 courses &lt;- tibble(course=c(&quot;ART220&quot;,&quot;ART330&quot;,&quot;BIO115&quot;,&quot;BIO234&quot;,&quot;BIO370&quot;,&quot;BIO490&quot;, &quot;CHM110&quot;,&quot;CHM220&quot;,&quot;CHM360&quot;,&quot;IDS101&quot;,&quot;IDS490&quot;,&quot;MTH107&quot;, &quot;MTH140&quot;,&quot;MTH230&quot;,&quot;OED212&quot;,&quot;OED330&quot;,&quot;OED360&quot;,&quot;PSY110&quot;, &quot;PSY370&quot;,&quot;SCD110&quot;,&quot;SCD330&quot;,&quot;SCD440&quot;,&quot;SOC111&quot;,&quot;SOC480&quot;), credits=c(3,3,4,4,4,4,4,4,4,3,4,4,4,4,3,3,3,4,4,3,3,4,4,4), instructor=c(&quot;Duffy&quot;,&quot;Terry&quot;,&quot;Johnson&quot;,&quot;Goyke&quot;,&quot;Anich&quot;,&quot;Anich&quot;, &quot;Carlson&quot;,&quot;Robertson&quot;,&quot;Carlson&quot;,&quot;Goyke&quot;,&quot;Hannickel&quot;,&quot;Ogle&quot;, &quot;Jensen&quot;,&quot;Jensen&quot;,&quot;Andre&quot;,&quot;Andre&quot;,&quot;Coulson&quot;,&quot;Sneyd&quot;, &quot;Sneyd&quot;,&quot;Tochterman&quot;,&quot;Tochterman&quot;,&quot;Foster&quot;, &quot;Schanning&quot;,&quot;Schanning&quot;)) courses #R&gt; # A tibble: 24 x 3 #R&gt; course credits instructor #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 ART220 3 Duffy #R&gt; 2 ART330 3 Terry #R&gt; 3 BIO115 4 Johnson #R&gt; 4 BIO234 4 Goyke #R&gt; 5 BIO370 4 Anich #R&gt; 6 BIO490 4 Anich #R&gt; 7 CHM110 4 Carlson #R&gt; 8 CHM220 4 Robertson #R&gt; 9 CHM360 4 Carlson #R&gt; 10 IDS101 3 Goyke #R&gt; # ... with 14 more rows These two data frames are related via the common course variable. This type of database organization is particularly useful because the information about any one course only needs to be entered once in courses even though the actual course may appear many times in schedules. This helps save time and reduces data entry errors. It is easy to add the specific course information (credits and instructor) from courses to the students course information in schedules with a left_join(). schedules2 &lt;- left_join(schedules,courses,by=&quot;course&quot;) schedules2 #R&gt; # A tibble: 20 x 4 #R&gt; studentID course credits instructor #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 4 Ogle #R&gt; 2 34535 BIO115 4 Johnson #R&gt; 3 34535 CHM110 4 Carlson #R&gt; 4 34535 IDS101 3 Goyke #R&gt; 5 45423 SCD110 3 Tochterman #R&gt; 6 45423 PSY110 4 Sneyd #R&gt; 7 45423 MTH140 4 Jensen #R&gt; 8 45423 OED212 3 Andre #R&gt; 9 45423 IDS101 3 Goyke #R&gt; 10 73424 BIO234 4 Goyke #R&gt; 11 73424 CHM220 4 Robertson #R&gt; 12 73424 BIO370 4 Anich #R&gt; 13 73424 SCD110 3 Tochterman #R&gt; 14 89874 SCD440 4 Foster #R&gt; 15 89874 PSY370 4 Sneyd #R&gt; 16 89874 IDS490 4 Hannickel #R&gt; 17 98222 SCD440 4 Foster #R&gt; 18 98222 SCD330 3 Tochterman #R&gt; 19 98222 SOC480 4 Schanning #R&gt; 20 98222 ART220 3 Duffy Note here that if we consider schedules as the primary data frame of interest then this relationship is still a one-to-one relationship because each course in schedules can be connected to only one course record in courses.   The students personal information can also be added to these results with a left_join() but now using the studentID key variable. schedules2 &lt;- left_join(personal,schedules2,by=&quot;studentID&quot;) schedules2 #R&gt; studentID first_nm last_nm hometown homestate course credits #R&gt; 1 34535 Rolando Blackman Windsor MI MTH107 4 #R&gt; 2 34535 Rolando Blackman Windsor MI BIO115 4 #R&gt; 3 34535 Rolando Blackman Windsor MI CHM110 4 #R&gt; 4 34535 Rolando Blackman Windsor MI IDS101 3 #R&gt; 5 45423 Catherine Johnson Eden Prairie MN SCD110 3 #R&gt; 6 45423 Catherine Johnson Eden Prairie MN PSY110 4 #R&gt; 7 45423 Catherine Johnson Eden Prairie MN MTH140 4 #R&gt; 8 45423 Catherine Johnson Eden Prairie MN OED212 3 #R&gt; 9 45423 Catherine Johnson Eden Prairie MN IDS101 3 #R&gt; 10 73424 James Carmichael Marion IA BIO234 4 #R&gt; 11 73424 James Carmichael Marion IA CHM220 4 #R&gt; 12 73424 James Carmichael Marion IA BIO370 4 #R&gt; 13 73424 James Carmichael Marion IA SCD110 3 #R&gt; 14 89874 Rachel Brown Milwaukee WI SCD440 4 #R&gt; 15 89874 Rachel Brown Milwaukee WI PSY370 4 #R&gt; 16 89874 Rachel Brown Milwaukee WI IDS490 4 #R&gt; 17 98222 Esteban Perez El Paso TX SCD440 4 #R&gt; 18 98222 Esteban Perez El Paso TX SCD330 3 #R&gt; 19 98222 Esteban Perez El Paso TX SOC480 4 #R&gt; 20 98222 Esteban Perez El Paso TX ART220 3 #R&gt; instructor #R&gt; 1 Ogle #R&gt; 2 Johnson #R&gt; 3 Carlson #R&gt; 4 Goyke #R&gt; 5 Tochterman #R&gt; 6 Sneyd #R&gt; 7 Jensen #R&gt; 8 Andre #R&gt; 9 Goyke #R&gt; 10 Goyke #R&gt; 11 Robertson #R&gt; 12 Anich #R&gt; 13 Tochterman #R&gt; 14 Foster #R&gt; 15 Sneyd #R&gt; 16 Hannickel #R&gt; 17 Foster #R&gt; 18 Tochterman #R&gt; 19 Schanning #R&gt; 20 Duffy These data frames represents a one-to-many relationship because studentID in personal is connected to many studentID records in schedules2 (one for each course the student is enrolled in).   4.3.2 Resource Sampling Data (One-to-Many Relationship) In sampling of natural resources it is common to have one database for information about the unit of sampling and another database specific to items within that sampling unit. For example, in fisheries we may have one database to record information about a particular net (e.g., where it is located, the date it was set) and a second database that records the species of fish caught and number of the species caught. You may be tempted to do this all in one database with a separate field for each fish species but this is inefficient as you may not know which species you may catch. Thus, every time you catch a new species you would need to add a new field or column to your database. In addition, this would be highly inefficient if you were to record information about individual fish (e.g., length and weight) as the amount of this information may vary from net to net. In this simple example, information about five specific settings of a net is stored in nets, which has a unique identifier for each net setting called net_num. nets &lt;- data.frame(net_num=1:5, lake=c(&quot;Eagle&quot;,&quot;Hart&quot;,&quot;Hart&quot;,&quot;Eagle&quot;,&quot;Millicent&quot;), date=c(&quot;3-Jul-21&quot;,&quot;3-Jul-21&quot;,&quot;5-Jul-21&quot;,&quot;6-Jul-21&quot;,&quot;6-Jul-21&quot;)) nets #R&gt; net_num lake date #R&gt; 1 1 Eagle 3-Jul-21 #R&gt; 2 2 Hart 3-Jul-21 #R&gt; 3 3 Hart 5-Jul-21 #R&gt; 4 4 Eagle 6-Jul-21 #R&gt; 5 5 Millicent 6-Jul-21 In a separate data frame the researchers recorded the species and number of each species caught in each net. Here there is a separate row for each species and its number caught with each row indexed to the specific net with the net_num key variable. catch &lt;- data.frame(net_num=c(1,1,2,2,2,4,4,5), species=c(&quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;,&quot;Bluntnose Minnow&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Largemouth Bass&quot;), number=c(7,3,19,2,56,3,6,3)) catch #R&gt; net_num species number #R&gt; 1 1 Bluegill 7 #R&gt; 2 1 Largemouth Bass 3 #R&gt; 3 2 Bluegill 19 #R&gt; 4 2 Largemouth Bass 2 #R&gt; 5 2 Bluntnose Minnow 56 #R&gt; 6 4 Bluegill 3 #R&gt; 7 4 Largemouth Bass 6 #R&gt; 8 5 Largemouth Bass 3 These data frames illustrate a one-to-many relationship as each record in nets may be connected to multiple records in catch. The catch data will be joined to the net data using a left_join() because it is important to keep track of nets that also did not catch fish. An inner_join() would only return nets where some fish were caught. fishcatch &lt;- left_join(nets,catch,by=&quot;net_num&quot;) fishcatch #R&gt; net_num lake date species number #R&gt; 1 1 Eagle 3-Jul-21 Bluegill 7 #R&gt; 2 1 Eagle 3-Jul-21 Largemouth Bass 3 #R&gt; 3 2 Hart 3-Jul-21 Bluegill 19 #R&gt; 4 2 Hart 3-Jul-21 Largemouth Bass 2 #R&gt; 5 2 Hart 3-Jul-21 Bluntnose Minnow 56 #R&gt; 6 3 Hart 5-Jul-21 &lt;NA&gt; NA #R&gt; 7 4 Eagle 6-Jul-21 Bluegill 3 #R&gt; 8 4 Eagle 6-Jul-21 Largemouth Bass 6 #R&gt; 9 5 Millicent 6-Jul-21 Largemouth Bass 3 The visualizations in this section are modified from https://twitter.com/hadleywickham/status/684407629259526148/photo/1. In this treatment, the unique id values are also uniquely color coded to help track individual observations in the descriptions below. Finding all combinations, however, is not needed to actually join two data frames. If by= is not explicitly set by the user then the two data frames will be joined using the variable(s) that the two data frames have in common for by=. A message will be displayed about which variable(s) was used; check this message carefully to make sure you are joining by the variables that you want to join by. I switched to using tibble() in the last two data frams only so that they may potentially print in a more concise manner. "],["pivot.html", "Module 5 Pivot 5.1 Data Formats 5.2 Pivoting Concepts 5.3 Pivoting in R 5.4 Examples with Context", " Module 5 Pivot Three rules of tidy data were introduced in Section 2.4. Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. There are a wide variety of ways to enter data. Some data will not be tidy because, for instance, it may be easier to enter data in a non-tidy format. For example, the data shown below is the number of positive confirmed COVID cases in Ashland, Bayfield, and Douglas counties in 2021 (through June).   County Jan_2021 Feb_2021 Mar_2021 Apr_2021 May_2021 Jun_2021 Ashland 139 27 31 41 45 3 Bayfield 100 33 28 54 36 15 Douglas 470 89 119 227 148 32   Data for future months can be easily entered by simply appending a new month on the right. These data are also easy to examine in this table, but in this format they are difficult to graph and can be difficult to summarize. Thus, these data need to be converted to a different format for some simple analyses.11 The objective of this module is to describe and demonstrate concepts and methods for converting data betwen different formats.   5.1 Data Formats Consider a situation with one measurement variable, x, recorded on four individuals at two times. These eight measurements could be entered in either the W or L data frames shown below.   W data.frame id x1 x2 A 1 5 B 2 6 C 3 7 D 4 8 L data.frame id time x A 1 1 A 2 5 B 1 2 B 2 6 C 1 3 C 2 7 D 1 4 D 2 8   In this case, a measurement of x on an individual at a single point in time is an observation; thus, each row should correspond to one measurement (value of x) on one individual. The W data frame is not tidy because multiple observations of x appear in each row of the data frame (i.e., the single measurement variable, x, is dispersed across two columns). The L data frame is tidy because each row corresponds to one observation (i.e., a unique combination of id and time) and the single measurement variable, x, now appears in only one column. Consider a similar example where two measurements (the variables x and y) were made (at the same time) on four individuals. These data may be entered as in V and Z below.   V data.frame id x y A 1 5 B 2 6 C 3 7 D 4 8 Z data.frame id variable value A x 1 A y 5 B x 2 B y 6 C x 3 C y 7 D x 4 D y 8   In this case V is tidy because each row corresponds to one observation (defined only by id) and each measurement variable (x and y) is in its own column. On the other hand Z is not tidy because observations are split into two rows and values of the two different measurement variables are lumped into the same column.   As you can see it can be difficult to identify the format that you want for your data. You cannot tell simply by the shape of the data  there will be times when you need the data to be longer (as in the first example above) and other times when you need the data to be wider (as in the second example above). As a general rule you should strive for your data to be tidy. For this start by identifying an observation is, which variables define the observations, and what the measurement variables are. Then determine if each row corresponds to one observation and if each measurement variable is in one column by itself. If the data do not meet these requirements then you likely need to convert it to a different format as described in the next sections.   5.2 Pivoting Concepts Each set of data described in the previous section could be entered in two formats. These formats are loosely called wider and longer based on their shapes relative to each other. converting between wider and longer format data is called A pivot. 5.2.1 Pivot Longer Pivot Longer is the conversion from a wider to a longer format. Pivotig to a longer format is usually needed if multiple observations of the same variable are recorded on individuals but are stored in separate columns of the data frame. This was the case with W above and also with the COVID data in the module introduction. To pivot from a wider to a longer format you must identify the variables in the wider format frame that contain the multiple measurements of the same variable. This was x1 and x2 in W. All other variables in the data frame are considered to represent a unique individual. In this case only the id variable is needed for this purpose. In addition, you must define names for variables in what will be the new longer format. The first name is for the variable that will identify the multiple measurements on the same individual. In this example the multiple measurements were taken at different times, so it seems logical to call the new variable time. The second name is for the variable that will hold the values of the measurement variable. Here the use of x1 and x2 in the original wider data frame suggest that this variable should be called x. The process of pivoting the wider W to a longer data frame is illustrated below.   5.2.2 Pivot Wider Pivot Wider is the conversion from a longer to a wider format. Pivoting to a wider format is most common when multiple measurement variables are recorded as one variable in the long format data frame. This was the case with Z from above. To pivot from a longer to a wider format you must identify the variable in the longer data frame that contains what will be names of variables in the wider data. The wider data frame that will be created from Z should have x and y has names of variables; thus, this variable in Z is variable. In addition, you must identify the variable in the long data frame that has the values of the measurement variable that will be separated into columns in the new data frame. In Z this variale is value. The process of pivoting the longer Z to a wider data frame is illustrated below.     5.3 Pivoting in R Pivoting W to a longer format and Z to a wider format in R are demonstrated in this section. These two data frames are created in R below. W &lt;- data.frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),x1=1:4,x2=5:8) W #R&gt; id x1 x2 #R&gt; 1 A 1 5 #R&gt; 2 B 2 6 #R&gt; 3 C 3 7 #R&gt; 4 D 4 8 Z &lt;- data.frame(id=rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),each=2), variable=rep(c(&quot;x&quot;,&quot;y&quot;),times=4), value=c(1,5,2,6,3,7,4,8)) Z #R&gt; id variable value #R&gt; 1 A x 1 #R&gt; 2 A y 5 #R&gt; 3 B x 2 #R&gt; 4 B y 6 #R&gt; 5 C x 3 #R&gt; 6 C y 7 #R&gt; 7 D x 4 #R&gt; 8 D y 8 5.3.1 Pivot Longer Pivoting to a longer data frame is accomplished with pivot_longer() from tidyr (which is part of tidyverse). The first argument is the name of the wider data frame. The following three arguments are also typically used. The variables in the wider data frame that represent multiple measurements of the same variable must be given in cols=. Note that these variables do NOT need to be in quotes because they exist in the wider data frame. There are multiple ways to select these variables in most situations; here are several for this situation.12 cols=x1:x2 will select all variables contiguous from between x1 to x2. cols=c(x1,x2) will select only variables x1 and x2. cols=starts_with(\"x\") will select all variables with names that begin with x. cols=-id will select all variables not named id. The name for the variable in the new longer data frame that will hold the index for multiple measurements on the same individual in the longer data frame is given in names_to=. The name for the variable that will hold the values of the measurement variable in the new longer data frame is given in values_to. Note that the variable names in names_to= and values_to= must be in quotes because they do not appear in an (as of yet) existing data frame. Given the definitions of these items in the previous section, the following code is used to pivot W to a longer format data frame, L. L &lt;- pivot_longer(W,cols=x1:x2,names_to=&quot;time&quot;,values_to=&quot;value&quot;) L #R&gt; # A tibble: 8 x 3 #R&gt; id time value #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A x1 1 #R&gt; 2 A x2 5 #R&gt; 3 B x1 2 #R&gt; 4 B x2 6 #R&gt; 5 C x1 3 #R&gt; 6 C x2 7 #R&gt; 7 D x1 4 #R&gt; 8 D x2 8 Note, however, that the time variable in L contains x1 and x2 rather than 1 and 2. By default pivot_longer() uses the names of the variables you supplied in cols= in this variable. If these variables have a common pattern  as in they all start with x and end with the number that we want  then the portion of the pattern to remove can be given in names_prefix=.13 L &lt;- pivot_longer(W,cols=x1:x2,names_to=&quot;time&quot;,names_prefix=&quot;x&quot;,values_to=&quot;x&quot;) L #R&gt; # A tibble: 8 x 3 #R&gt; id time x #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A 1 1 #R&gt; 2 A 2 5 #R&gt; 3 B 1 2 #R&gt; 4 B 2 6 #R&gt; 5 C 1 3 #R&gt; 6 C 2 7 #R&gt; 7 D 1 4 #R&gt; 8 D 2 8   A reminder that all variables not given in cols= will be considered as identifying with the individuals in the data frame. Suppose for example that W had more columns that looked like this data frame called W2. #R&gt; id fname lname years x1 x2 #R&gt; 1 A Derek Ogle 25 1 5 #R&gt; 2 B Young Kim 32 2 6 #R&gt; 3 C Andrew Jensen 6 3 7 #R&gt; 4 D Jodi Supanich 7 4 8 The same pivot_longer() with W2 will repeat the id, fname, lname, and years values in the longer data frame L2. L2 &lt;- pivot_longer(W2,cols=x1:x2,names_to=&quot;time&quot;,names_prefix=&quot;x&quot;,values_to=&quot;value&quot;) L2 #R&gt; # A tibble: 8 x 6 #R&gt; id fname lname years time value #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A Derek Ogle 25 1 1 #R&gt; 2 A Derek Ogle 25 2 5 #R&gt; 3 B Young Kim 32 1 2 #R&gt; 4 B Young Kim 32 2 6 #R&gt; 5 C Andrew Jensen 6 1 3 #R&gt; 6 C Andrew Jensen 6 2 7 #R&gt; 7 D Jodi Supanich 7 1 4 #R&gt; 8 D Jodi Supanich 7 2 8   5.3.2 Pivot Wider Pivoting to a wider data frame is accomplished with pivot_wider() from tidyr. The first argument is the name of the longer data frame. The following two arguments are also typically used. The name of the variable in the longer data frame that contains what will be names of variables in the wider data frame is given in names_from=. The name of the variable in the longer data frame that has values of the measurement variable that will be separated into columns in the new data frame is given in values_from=. As both of these variables exist in the longer data frame they do NOT need to be in quotes. Given the definitions from the previous section, the following is used to pivot Z to a wider format, V. V &lt;- pivot_wider(Z,names_from=variable,values_from=value) V #R&gt; # A tibble: 4 x 3 #R&gt; id x y #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 A 1 5 #R&gt; 2 B 2 6 #R&gt; 3 C 3 7 #R&gt; 4 D 4 8   Again, you can imagine a slightly more complicated data frame (here called Z2). #R&gt; id fname lname years variable value #R&gt; 1 A Derek Ogle 25 x 1 #R&gt; 2 A Derek Ogle 25 y 5 #R&gt; 3 B Young Kim 32 x 2 #R&gt; 4 B Young Kim 32 y 6 #R&gt; 5 C Andrew Jensen 6 x 3 #R&gt; 6 C Andrew Jensen 6 y 7 #R&gt; 7 D Jodi Supanich 7 x 4 #R&gt; 8 D Jodi Supanich 7 y 8 The same pivot_wider() on Z2 will collapse the common id, fname, lname, and years variables. V2 &lt;- pivot_wider(Z2,names_from=variable,values_from=value) V2 #R&gt; # A tibble: 4 x 6 #R&gt; id fname lname years x y #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 A Derek Ogle 25 1 5 #R&gt; 2 B Young Kim 32 2 6 #R&gt; 3 C Andrew Jensen 6 3 7 #R&gt; 4 D Jodi Supanich 7 4 8   5.4 Examples with Context 5.4.1 COVID Cases by County and Month A simple data frame of COVID cases by month in three Wisconsin counties from January to June 2021 was shown in the introduction. Here consider an even wider data, covABD_W, of monthly cases for all three counties from March 2020 to June 2021. covABD_W #R&gt; # A tibble: 3 x 17 #R&gt; # Groups: County [3] #R&gt; County Mar_2020 Apr_2020 May_2020 Jun_2020 Jul_2020 Aug_2020 Sep_2020 Oct_2020 #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 Ashla~ 1 1 0 1 16 16 94 167 #R&gt; 2 Bayfi~ 3 0 0 0 16 26 71 160 #R&gt; 3 Dougl~ 6 3 10 11 93 133 268 316 #R&gt; # ... with 8 more variables: Nov_2020 &lt;dbl&gt;, Dec_2020 &lt;dbl&gt;, Jan_2021 &lt;dbl&gt;, #R&gt; # Feb_2021 &lt;dbl&gt;, Mar_2021 &lt;dbl&gt;, Apr_2021 &lt;dbl&gt;, May_2021 &lt;dbl&gt;, #R&gt; # Jun_2021 &lt;dbl&gt; In this case a measurement is number of COVID cases and an observation is a combination of month and county. Thus, these data are not tidy because number of COVID cases is not in one column and each row is not one combination of county and month. It would be difficult to plot number of cases by month for each county with data in this format. Thus these wider data need to be converted to longer data that are tidy. All columns except County are part of the data to pivot; thus, cols=-County is the easiest way to choose these columns. The variable names in covABD_W are the month and year of the data so I will call the names_to= variable MonYear. Finally, the measurements are of cases of COVID so I will call the values_to= variable Cases. Putting this together gives the following. covABD_L &lt;- pivot_longer(covABD_W,cols=-County,names_to=&quot;MonYear&quot;,values_to=&quot;Cases&quot;) covABD_L #R&gt; # A tibble: 48 x 3 #R&gt; # Groups: County [3] #R&gt; County MonYear Cases #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 Ashland Mar_2020 1 #R&gt; 2 Ashland Apr_2020 1 #R&gt; 3 Ashland May_2020 0 #R&gt; 4 Ashland Jun_2020 1 #R&gt; 5 Ashland Jul_2020 16 #R&gt; 6 Ashland Aug_2020 16 #R&gt; 7 Ashland Sep_2020 94 #R&gt; 8 Ashland Oct_2020 167 #R&gt; 9 Ashland Nov_2020 378 #R&gt; 10 Ashland Dec_2020 331 #R&gt; # ... with 38 more rows This worked but the MonYear variable is problematic because R does not recognize it as a date (note how it is identified as character class). It would be better to split these names on the underscore to get one variable with the months and one variale with the years. Names may be split in pivot_longer() by providing the character to split on in names_sep=. As splitting the names will produce two new variales, names_to= must be a vector with two names for these two new columns. These modifications produce the following result. covABD_L &lt;- pivot_longer(covABD_W,cols=-County, names_to=c(&quot;Month&quot;,&quot;Year&quot;),names_sep=&quot;_&quot;,values_to=&quot;Cases&quot;) covABD_L #R&gt; # A tibble: 48 x 4 #R&gt; # Groups: County [3] #R&gt; County Month Year Cases #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 Ashland Mar 2020 1 #R&gt; 2 Ashland Apr 2020 1 #R&gt; 3 Ashland May 2020 0 #R&gt; 4 Ashland Jun 2020 1 #R&gt; 5 Ashland Jul 2020 16 #R&gt; 6 Ashland Aug 2020 16 #R&gt; 7 Ashland Sep 2020 94 #R&gt; 8 Ashland Oct 2020 167 #R&gt; 9 Ashland Nov 2020 378 #R&gt; 10 Ashland Dec 2020 331 #R&gt; # ... with 38 more rows We will need an actual date variable to make a plot of COVID cases over time. The code below does this but uses functions that wont be introduced until Modules XXX and XXX. covABD_L &lt;- covABD_L %&gt;% mutate(Date=lubridate::mdy(paste(Month,&quot;1&quot;,Year,sep=&quot;-&quot;))) covABD_L #R&gt; # A tibble: 48 x 5 #R&gt; # Groups: County [3] #R&gt; County Month Year Cases Date #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;date&gt; #R&gt; 1 Ashland Mar 2020 1 2020-03-01 #R&gt; 2 Ashland Apr 2020 1 2020-04-01 #R&gt; 3 Ashland May 2020 0 2020-05-01 #R&gt; 4 Ashland Jun 2020 1 2020-06-01 #R&gt; 5 Ashland Jul 2020 16 2020-07-01 #R&gt; 6 Ashland Aug 2020 16 2020-08-01 #R&gt; 7 Ashland Sep 2020 94 2020-09-01 #R&gt; 8 Ashland Oct 2020 167 2020-10-01 #R&gt; 9 Ashland Nov 2020 378 2020-11-01 #R&gt; 10 Ashland Dec 2020 331 2020-12-01 #R&gt; # ... with 38 more rows Finally, these data can be graphed as shown below.   5.4.2 Abundance of Mayflies In 1990 technicians for the U.S. Geological Survey recorded the abundance of mayflies (Ephemeroptera) in 10 1 m2 quadrats in Chequamegon Bay. In 2020 they repeat the collections at the same locations. Their data are recorded in ephem as shown below. ephem #R&gt; # A tibble: 20 x 5 #R&gt; loc hab depth year abundance #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Sand 16 1990 47 #R&gt; 2 101 Sand 16 2020 46 #R&gt; 3 102 Sand 20 1990 44 #R&gt; 4 102 Sand 20 2020 42 #R&gt; 5 103 Muck 23 1990 50 #R&gt; 6 103 Muck 23 2020 53 #R&gt; 7 104 Cobble 27 1990 54 #R&gt; 8 104 Cobble 27 2020 56 #R&gt; 9 105 Sand 15 1990 52 #R&gt; 10 105 Sand 15 2020 43 #R&gt; 11 106 Muck 21 1990 25 #R&gt; 12 106 Muck 21 2020 30 #R&gt; 13 107 Cobble 27 1990 36 #R&gt; 14 107 Cobble 27 2020 20 #R&gt; 15 108 Sand 13 1990 22 #R&gt; 16 108 Sand 13 2020 18 #R&gt; 17 109 Sand 10 1990 28 #R&gt; 18 109 Sand 10 2020 28 #R&gt; 19 110 Cobble 23 1990 40 #R&gt; 20 110 Cobble 23 2020 36 The researchers want to compute the mean change in abundance across all ten quadrats. To facilitate that calculation these data need to be converted to a wider format that will have the 1990 and 2020 data in separate columns. In this case, potential names for the variables in the new wider format are in the year variable. The values to be put in those columns are in the aboundance variable. The rest of the variables should be maintained as they identify the observation (i.e., a quadrat year combination). With these definitions these data are converted to a wider format with the following code. ephem2 &lt;- pivot_wider(ephem,names_from=year,values_from=abundance) ephem2 #R&gt; # A tibble: 10 x 5 #R&gt; loc hab depth `1990` `2020` #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Sand 16 47 46 #R&gt; 2 102 Sand 20 44 42 #R&gt; 3 103 Muck 23 50 53 #R&gt; 4 104 Cobble 27 54 56 #R&gt; 5 105 Sand 15 52 43 #R&gt; 6 106 Muck 21 25 30 #R&gt; 7 107 Cobble 27 36 20 #R&gt; 8 108 Sand 13 22 18 #R&gt; 9 109 Sand 10 28 28 #R&gt; 10 110 Cobble 23 40 36 This accomplishes the task at hand, but the two new variables are called 1990 and 2020, which are non-standard variable names in R (i.e., they start with numbers). This issue can be avoided by providing a string to be used as a prefix to the names in names_prefix=. ephem2 &lt;- pivot_wider(ephem,names_from=year,names_prefix=&quot;year_&quot;,values_from=abundance) ephem2 #R&gt; # A tibble: 10 x 5 #R&gt; loc hab depth year_1990 year_2020 #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Sand 16 47 46 #R&gt; 2 102 Sand 20 44 42 #R&gt; 3 103 Muck 23 50 53 #R&gt; 4 104 Cobble 27 54 56 #R&gt; 5 105 Sand 15 52 43 #R&gt; 6 106 Muck 21 25 30 #R&gt; 7 107 Cobble 27 36 20 #R&gt; 8 108 Sand 13 22 18 #R&gt; 9 109 Sand 10 28 28 #R&gt; 10 110 Cobble 23 40 36 The code below, which will not be introduced until Module XXX, creates a new variable that is the difference in abundance between the two years. ephem2 &lt;- ephem2 %&gt;% mutate(diff20_90=year_2020-year_1990) ephem2 #R&gt; # A tibble: 10 x 6 #R&gt; loc hab depth year_1990 year_2020 diff20_90 #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Sand 16 47 46 -1 #R&gt; 2 102 Sand 20 44 42 -2 #R&gt; 3 103 Muck 23 50 53 3 #R&gt; 4 104 Cobble 27 54 56 2 #R&gt; 5 105 Sand 15 52 43 -9 #R&gt; 6 106 Muck 21 25 30 5 #R&gt; 7 107 Cobble 27 36 20 -16 #R&gt; 8 108 Sand 13 22 18 -4 #R&gt; 9 109 Sand 10 28 28 0 #R&gt; 10 110 Cobble 23 40 36 -4 These data could then be easily plotted or summarized. Converting and graphing these data will be shown in Section 5.4. There are still other ways (e.g., cols=contains(\"x\")) but these four would be the most common given the names in this data frame. There are other arguments to pivot_longer() for dealing with more complicated naming issues. "],["wrangle-columns.html", "Module 6 Wrangle Columns 6.1 dplyr verbs 6.2 Pipe 6.3 Selecting Columns 6.4 Moving Columns 6.5 Renaming Columns 6.6 Adding Columns 6.7 Examples in Context", " Module 6 Wrangle Columns Previous modules were primarily focused on reading data into R and making sure it was tidy. In this module we will start wrangling data by manipulating columns or variables. Module 7 will further describe how to wrangle data through manipulating rows. More complex wrangling topics will be discussed in modules after that. The descriptive examples below will use the bears data frame from Section 3.3.1. bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas   6.1 dplyr verbs The primary tools for manipulating data frames used in this course are verbs from the dplyr package. These verbs are a suite of functions for selecting columns, arranging columns, renaming columns, selecting rows, etc. These functions will be described in more detail in subsequent sections and modules but each function has these same characteristics: The first argument is a data frame or tibble. Further arguments are directives explaining how to manipulate the data frame. Variables do not need to be given in quotes. A data frame or tibble is returned from the function. Thus, these verbs have this general format. new_df &lt;- verb(old_df,...) where new_df is a new resultant data frame, verb is the name of the dplyr verb, old_df is the old original data frame, and ... will be replaced with directive arguments. 6.2 Pipe As you will see in future modules, several dplyr verbs may be used consecutively. For example, you may use verbs to select just the females in the data frame, add on a new variable that calculates body mass index, and then order the observations from lowest to highest BMI. The pipe operator, %&gt;%, allows consecutive verbs to be connected in a more efficient and readable manner. The pipe takes the data frame from in front of %&gt;% and places it into the first argument (by default) of the function after the %&gt;%. For example, the general format of a dplyr verb from above could be rewritten like this new_df &lt;- old_df %&gt;% verb(...) because %&gt;% will pipe old_df into the first argument of verb(). This may not look simpler in this case, but it allows for code like this new_df &lt;- verb1(old_df,...) new_df &lt;- verb2(new_df,...) new_df &lt;- verb3(new_df,...) to be written more efficiently and expressively like this new_df &lt;- old_df %&gt;% verb1(...) %&gt;% verb2(...) %&gt;% verb3(...) When reading this code think of replacing the pipe with then. For example, the last code above could be read as a new data frame is created by starting with an old data frame and THEN applying verb1 and THEN verb2 and THEN verb3.   The pipe and assign operator, %&lt;&gt;%, will also be used in this and subsequent modules. This operator takes the data frame to the left and puts it in the first object of the function on the right AND then takes the results of the function and assigns it to the name of the data frame to the left of the operator. In other words, code like this old_df &lt;- old_df %&gt;% verb() can be replaced with this old_df %&lt;&gt;% verb() Be careful with this operator as the old data frame will be replaced with the result of the verb. These pipe operatures will be used hereafter, even for single lines of code so that you become more familiar with its use for more involved future examples.   6.3 Selecting Columns Recall from Section 2.3 that individual variables (or columns) can be selected from a data frame with dataframename$variablename. For example, the following code selects the loc variable from the bears data frame. bears$loc #R&gt; [1] &quot;Bayfield&quot; &quot;Bayfield&quot; &quot;Bayfield&quot; &quot;Ashland&quot; &quot;Ashland&quot; &quot;Douglas&quot; &quot;Douglas&quot; #R&gt; [8] &quot;Douglas&quot;   However, in this section, we are more interested in selecting multiple variables from a data frame, rather than a single variable, to form a new data frame. This may be useful when working with a data frame that has a very large number of variables/columns. Variables are selected from a data frame with select(). Variables to retain can be selected in a wide variety of ways as shown in Table 6.1. As you will see in the examples, multiple methods may be used to select the same variables, but you may find that some ways can make your code more succinct and readable.   Table 6.1: Methods to select columns from a data frame using select(). Note that numbers and variable names will be replaced with numbers and names specific to the selection process (see examples in main text). Selector Column/Variables Returned 2 2nd column c(2,3) 2nd &amp; 3rd columns 2:5 All columns between 2nd and 5th columns -2 All but the 2nd column x Column named x c(x,y) Columns named x and y x:z All columns between columns named x and z -x All but the column named x starts_with(\"x\") All columns with names that start with x starts_with(c(\"x\",\"y\")) All columns with names that start with x or y ends_with(\"x\") All columns with names that end with x contains(\"x\") All columns with names that contain an x any_of(c(\"x\",\"y\")) Any (or all) of the columns named x or y (exactly) all_of(c(\"x\",\"y\")) All columns named x or y (exactly)14 last_col() Last column everything() All columns   Below are examples of selecting variables from bears.15 Note that each resulting data frame is called tmp (for temporary) because it will not be used further here. Select first two variables. tmp &lt;- bears %&gt;% select(1:2) tmp #R&gt; # A tibble: 8 x 2 #R&gt; length.cm weight.kg #R&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 139 110 #R&gt; 2 120. 60 #R&gt; 3 149 85 #R&gt; 4 141 100 #R&gt; 5 141 95 #R&gt; 6 150 85 #R&gt; 7 130. 105 #R&gt; 8 150 110 Select all variables that contain a . tmp &lt;- bears %&gt;% select(contains(&quot;.&quot;)) tmp #R&gt; # A tibble: 8 x 2 #R&gt; length.cm weight.kg #R&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 139 110 #R&gt; 2 120. 60 #R&gt; 3 149 85 #R&gt; 4 141 100 #R&gt; 5 141 95 #R&gt; 6 150 85 #R&gt; 7 130. 105 #R&gt; 8 150 110 Select all variables that start with an l. tmp &lt;- bears %&gt;% select(starts_with(&quot;l&quot;)) tmp #R&gt; # A tibble: 8 x 2 #R&gt; length.cm loc #R&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 Bayfield #R&gt; 2 120. Bayfield #R&gt; 3 149 Bayfield #R&gt; 4 141 Ashland #R&gt; 5 141 Ashland #R&gt; 6 150 Douglas #R&gt; 7 130. Douglas #R&gt; 8 150 Douglas Select all variables except loc. tmp &lt;- bears %&gt;% select(-loc) tmp #R&gt; # A tibble: 8 x 2 #R&gt; length.cm weight.kg #R&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 139 110 #R&gt; 2 120. 60 #R&gt; 3 149 85 #R&gt; 4 141 100 #R&gt; 5 141 95 #R&gt; 6 150 85 #R&gt; 7 130. 105 #R&gt; 8 150 110 6.4 Moving Columns It is not necessary that variables be in a particular order in a data frame; however, you may find it easier to work with variables in a particular order. Variables can be moved within a data frame with relocate(). By default the selected columns are moved to the beginning of the data frame. However, they can be placed before or after a particular column by using .before= and .after=. Note that columns to be moved can be selected with methods shown in 6.1. Below are examples of moving variables within bears. Move loc variable to beginning. tmp &lt;- bears %&gt;% relocate(loc) tmp #R&gt; # A tibble: 8 x 3 #R&gt; loc length.cm weight.kg #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 Bayfield 139 110 #R&gt; 2 Bayfield 120. 60 #R&gt; 3 Bayfield 149 85 #R&gt; 4 Ashland 141 100 #R&gt; 5 Ashland 141 95 #R&gt; 6 Douglas 150 85 #R&gt; 7 Douglas 130. 105 #R&gt; 8 Douglas 150 110 Move loc variable to after length.cm. tmp &lt;- bears %&gt;% relocate(loc,.after=length.cm) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm loc weight.kg #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 139 Bayfield 110 #R&gt; 2 120. Bayfield 60 #R&gt; 3 149 Bayfield 85 #R&gt; 4 141 Ashland 100 #R&gt; 5 141 Ashland 95 #R&gt; 6 150 Douglas 85 #R&gt; 7 130. Douglas 105 #R&gt; 8 150 Douglas 110 Move loc variable to before weight.kg. tmp &lt;- bears %&gt;% relocate(loc,.before=weight.kg) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm loc weight.kg #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 139 Bayfield 110 #R&gt; 2 120. Bayfield 60 #R&gt; 3 149 Bayfield 85 #R&gt; 4 141 Ashland 100 #R&gt; 5 141 Ashland 95 #R&gt; 6 150 Douglas 85 #R&gt; 7 130. Douglas 105 #R&gt; 8 150 Douglas 110 Move length.cm variable to end. tmp &lt;- bears %&gt;% relocate(length.cm,.after=last_col()) tmp #R&gt; # A tibble: 8 x 3 #R&gt; weight.kg loc length.cm #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 110 Bayfield 139 #R&gt; 2 60 Bayfield 120. #R&gt; 3 85 Bayfield 149 #R&gt; 4 100 Ashland 141 #R&gt; 5 95 Ashland 141 #R&gt; 6 85 Douglas 150 #R&gt; 7 105 Douglas 130. #R&gt; 8 110 Douglas 150 Move both length.cm and weight.kg variables to the beginning. tmp &lt;- bears %&gt;% relocate(contains(&quot;.&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas 6.5 Renaming Columns Variables may be given new names with rename(). Each directive argument in rename() has the form newname=oldname where newname will be the new name for the oldname variable in the data frame. Below are examples of renaming variables in bears. Rename loc to Location. tmp &lt;- bears %&gt;% rename(Location=loc) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg Location #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Rename both length.cm and weight.kg. tmp &lt;- bears %&gt;% rename(Length=length.cm,Weight=weight.kg) tmp #R&gt; # A tibble: 8 x 3 #R&gt; Length Weight loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Non-standard names of variables must be included in backticks when renaming it. For example, suppose that the names of variables in bears2 look like this (note the spaces in the names of the first two variables). bears2 #R&gt; # A tibble: 8 x 3 #R&gt; `length (cm)` `weight (kg)` loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The following code is used to sensibly rename these variables. tmp &lt;- bears2 %&gt;% rename(Length=`length (cm)`,Weight=`weight (kg)`) tmp #R&gt; # A tibble: 8 x 3 #R&gt; Length Weight loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas 6.6 Adding Columns New variables may be added to a data frame with mutate(). The directive arguments to this function have the form newvar=XXX where newvar will be the name of the new variable and XXX will create a new variable. There are a wide variety of expressions and functions that can be used to construct a new variable. A few of these will be illustrated below with bears but it is impossible to demonstrate all possibilities. Thus, other examples will be shown in the full context examples below as well as in subsequent modules. Add a year variable that is a constant value. tmp &lt;- bears %&gt;% mutate(year=2021) tmp #R&gt; # A tibble: 8 x 4 #R&gt; length.cm weight.kg loc year #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 139 110 Bayfield 2021 #R&gt; 2 120. 60 Bayfield 2021 #R&gt; 3 149 85 Bayfield 2021 #R&gt; 4 141 100 Ashland 2021 #R&gt; 5 141 95 Ashland 2021 #R&gt; 6 150 85 Douglas 2021 #R&gt; 7 130. 105 Douglas 2021 #R&gt; 8 150 110 Douglas 2021 Add a length in inches variable derived from length.cm. tmp &lt;- bears %&gt;% mutate(length.in=length.cm/2.54) tmp #R&gt; # A tibble: 8 x 4 #R&gt; length.cm weight.kg loc length.in #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 139 110 Bayfield 54.7 #R&gt; 2 120. 60 Bayfield 47.4 #R&gt; 3 149 85 Bayfield 58.7 #R&gt; 4 141 100 Ashland 55.5 #R&gt; 5 141 95 Ashland 55.5 #R&gt; 6 150 85 Douglas 59.1 #R&gt; 7 130. 105 Douglas 51.0 #R&gt; 8 150 110 Douglas 59.1 Multiple variables can be created at one time by including more arguments to mutate(). Subsequent arguments in mutate() may use variables created previously in the same mutate(). For example, the code below adds new variables that represent the weight of the bear if it were healthy (based on its length), the difference between the observed weight and this healthy weight, and a note if the bear is more or less than the healthy weight. tmp &lt;- bears %&gt;% mutate(health.wt=0.1129*length.cm^1.366, rel_weight=weight.kg-health.wt, rel_health=ifelse(rel_weight&gt;0,&quot;MORE&quot;,&quot;less&quot;)) tmp #R&gt; # A tibble: 8 x 6 #R&gt; length.cm weight.kg loc health.wt rel_weight rel_health #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield 95.5 14.5 MORE #R&gt; 2 120. 60 Bayfield 78.6 -18.6 less #R&gt; 3 149 85 Bayfield 105. -20.0 less #R&gt; 4 141 100 Ashland 97.4 2.61 MORE #R&gt; 5 141 95 Ashland 97.4 -2.39 less #R&gt; 6 150 85 Douglas 106. -21.0 less #R&gt; 7 130. 105 Douglas 86.7 18.3 MORE #R&gt; 8 150 110 Douglas 106. 4.02 MORE In the above example ifelse() contains three arguments  a conditioning expression that can evaluate to either true or false, an item to return if the expression evaluates to true, and an item to return if the expression evaluates to false. This ifelse() can be read as if the relative weight is greater than 0 then return MORE otherwise return less. The ifelse() function is quite powerful for converting values to binary groups. However, case_when() is more flexible when more groups will be created. The case_when() function consists of several arguments of the form condition ~ return where condition is a condition expression and return is the item that will be returned if that condition expression evaluates to true. The conditions in the arguments are sequential such that the result for the first condition that evaluates to true is returned. The last condition expression in case_when is usually TRUE which will always evaluate to true and will thus return the last result if all previous conditions were not met. For example, the code below provides a bit more detailed description of the relative health of the bears. tmp &lt;- bears %&gt;% mutate(health.wt=0.1129*length.cm^1.366, rel_weight=weight.kg-health.wt, rel_health=case_when( rel_weight&gt;10 ~ &quot;MUCH MORE&quot;, rel_weight&gt;0 ~ &quot;SOME MORE&quot;, rel_weight&gt;-10 ~ &quot;some less&quot;, TRUE ~ &quot;much less&quot; )) tmp #R&gt; # A tibble: 8 x 6 #R&gt; length.cm weight.kg loc health.wt rel_weight rel_health #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield 95.5 14.5 MUCH MORE #R&gt; 2 120. 60 Bayfield 78.6 -18.6 much less #R&gt; 3 149 85 Bayfield 105. -20.0 much less #R&gt; 4 141 100 Ashland 97.4 2.61 SOME MORE #R&gt; 5 141 95 Ashland 97.4 -2.39 some less #R&gt; 6 150 85 Douglas 106. -21.0 much less #R&gt; 7 130. 105 Douglas 86.7 18.3 MUCH MORE #R&gt; 8 150 110 Douglas 106. 4.02 SOME MORE Finally, mapvalues() from the plyr package can be used to efficiently convert the groups in one categorical variable to groups in a second categorical variables. The arguments to this function are the name of the first categorical variable followed by the names of the groups of this variable in from= and the new names for the groups in the new variable in to=. Note that all group names not listed in from= will simply carry-over as-is in the new variable. For example, suppose that the locations in loc need to be converted to abbreviations to save space when graphing the data. tmp &lt;- bears %&gt;% mutate(loc_abb=plyr::mapvalues(loc, from=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;), to=c(&quot;ASH&quot;,&quot;BAY&quot;,&quot;DOU&quot;))) tmp #R&gt; # A tibble: 8 x 4 #R&gt; length.cm weight.kg loc loc_abb #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield BAY #R&gt; 2 120. 60 Bayfield BAY #R&gt; 3 149 85 Bayfield BAY #R&gt; 4 141 100 Ashland ASH #R&gt; 5 141 95 Ashland ASH #R&gt; 6 150 85 Douglas DOU #R&gt; 7 130. 105 Douglas DOU #R&gt; 8 150 110 Douglas DOU Alternatively suppose that Ashland and Bayfield need to be combined into one group for some reason. This can be accomplished by given the combined name for counties in the positions of to= that match the two countines in from=. For example, tmp &lt;- bears %&gt;% mutate(loc_abb=plyr::mapvalues(loc, from=c(&quot;Ashland&quot;,&quot;Bayfield&quot;), to=c(&quot;Ashland/Bayfield&quot;,&quot;Ashland/Bayfield&quot;))) tmp #R&gt; # A tibble: 8 x 4 #R&gt; length.cm weight.kg loc loc_abb #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield Ashland/Bayfield #R&gt; 2 120. 60 Bayfield Ashland/Bayfield #R&gt; 3 149 85 Bayfield Ashland/Bayfield #R&gt; 4 141 100 Ashland Ashland/Bayfield #R&gt; 5 141 95 Ashland Ashland/Bayfield #R&gt; 6 150 85 Douglas Douglas #R&gt; 7 130. 105 Douglas Douglas #R&gt; 8 150 110 Douglas Douglas Note in the code above that I did not include Douglas in either from= or to= because it was not to be modified for this situation.   6.7 Examples in Context 6.7.1 NBA Players Data on every players who has ever played in the National Basketball Association was read into R in Section 3.3.1. The structure of that data frame is shown below. players &lt;- read_csv(&quot;https://sports-statistics.com/database/basketball-data/nba/NBA-playerlist.csv&quot;) str(players,give.attr=FALSE) #R&gt; spec_tbl_df [4,393 x 15] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #R&gt; $ X1 : num [1:4393] 0 1 2 3 4 5 6 7 8 9 ... #R&gt; $ DISPLAY_FIRST_LAST : chr [1:4393] &quot;Alaa Abdelnaby&quot; &quot;Zaid Abdul-Aziz&quot; &quot;Kareem Abdul-Jabbar&quot; &quot;Mahmoud Abdul-Rauf&quot; ... #R&gt; $ DISPLAY_LAST_COMMA_FIRST : chr [1:4393] &quot;Abdelnaby, Alaa&quot; &quot;Abdul-Aziz, Zaid&quot; &quot;Abdul-Jabbar, Kareem&quot; &quot;Abdul-Rauf, Mahmoud&quot; ... #R&gt; $ FROM_YEAR : num [1:4393] 1990 1968 1969 1990 1997 ... #R&gt; $ GAMES_PLAYED_FLAG : chr [1:4393] &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ... #R&gt; $ OTHERLEAGUE_EXPERIENCE_CH: chr [1:4393] &quot;00&quot; &quot;00&quot; &quot;00&quot; &quot;00&quot; ... #R&gt; $ PERSON_ID : num [1:4393] 76001 76002 76003 51 1505 ... #R&gt; $ PLAYERCODE : chr [1:4393] &quot;HISTADD_alaa_abdelnaby&quot; &quot;HISTADD_zaid_abdul-aziz&quot; &quot;HISTADD_kareem_abdul-jabbar&quot; &quot;mahmoud_abdul-rauf&quot; ... #R&gt; $ ROSTERSTATUS : num [1:4393] 0 0 0 0 0 0 0 0 0 0 ... #R&gt; $ TEAM_ABBREVIATION : chr [1:4393] NA NA NA NA ... #R&gt; $ TEAM_CITY : chr [1:4393] NA NA NA NA ... #R&gt; $ TEAM_CODE : chr [1:4393] NA NA NA NA ... #R&gt; $ TEAM_ID : num [1:4393] 0 0 0 0 0 0 0 0 0 0 ... #R&gt; $ TEAM_NAME : chr [1:4393] NA NA NA NA ... #R&gt; $ TO_YEAR : num [1:4393] 1994 1977 1988 2000 2003 ...   Suppose that we ultimately want to make a graph related to the length of time that players were in the NBA. To facilitate this, I am going to reduce this data frame to only the players name, the year they started, and the year they ended in the NBA, rename some of the long variable names (and remove the capitalization), calculate the amount of time they were in the NBA by subtracting their start year from their end year, create a new variable called modern that is yes for players that ended their careers in 1980 or later and is no otherwise, and order the data from most to least years played,16 and examine the top 10 rows of the data frame.17 players2 &lt;- players %&gt;% select(DISPLAY_LAST_COMMA_FIRST,FROM_YEAR,TO_YEAR) %&gt;% rename(name=DISPLAY_LAST_COMMA_FIRST,start=FROM_YEAR,end=TO_YEAR) %&gt;% mutate(years_played=end-start, modern=ifelse(end&gt;=1980,&quot;yes&quot;,&quot;no&quot;)) %&gt;% arrange(desc(years_played)) players2 %&gt;% slice(1:10) #R&gt; # A tibble: 10 x 5 #R&gt; name start end years_played modern #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 Willis, Kevin 1984 2006 22 yes #R&gt; 2 Jones, Mark 1983 2004 21 yes #R&gt; 3 Carter, Vince 1998 2018 20 yes #R&gt; 4 Garnett, Kevin 1995 2015 20 yes #R&gt; 5 Nowitzki, Dirk 1998 2018 20 yes #R&gt; 6 Parish, Robert 1976 1996 20 yes #R&gt; 7 Abdul-Jabbar, Kareem 1969 1988 19 yes #R&gt; 8 Bryant, Kobe 1996 2015 19 yes #R&gt; 9 Cousy, Bob 1950 1969 19 no #R&gt; 10 Crawford, Jamal 2000 2018 18 yes   For fun, this is what one plot of the results might look like.   6.7.2 Wolves and Moose of Isle Royale For a module in my Great Graphs course I wanted to demonstrate to students how to create graphs that examined the abundance of Moose and Wolves on Isle Royale over time and in relation to winter temperatures and whether ice bridged formed between the mainland and Isle Royale. Fortunately, these data18 is available at Wolves &amp; Moose of Isle Royale. I downloaded the data file provided there and read it into R below.19 irmw &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;Data_wolves_moose_Isle_Royale_June2019.xlsx&quot;), sheet=&quot;1. population level data&quot;,skip=1,na=c(&quot;NA&quot;,&quot;N/A&quot;)) str(irmw,give.attr=FALSE) #R&gt; tibble [61 x 33] (S3: tbl_df/tbl/data.frame) #R&gt; $ year : num [1:61] 1959 1960 1961 1962 1963 ... #R&gt; $ wolves : num [1:61] 20 22 22 23 20 26 28 26 22 22 ... #R&gt; $ moose : num [1:61] 538 564 572 579 596 ... #R&gt; $ kill rate : chr [1:61] NA NA NA NA ... #R&gt; $ predation rate : chr [1:61] NA NA NA NA ... #R&gt; $ f (wolves) : chr [1:61] NA NA NA NA ... #R&gt; $ ancestry (immigrant wolf) : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ Juvenile Survival : chr [1:61] NA NA NA NA ... #R&gt; $ Adult Survival : chr [1:61] NA NA NA NA ... #R&gt; $ overall survival (genetic-CR) : chr [1:61] NA NA NA NA ... #R&gt; $ overall survival (field-based estimate) : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ % mortality, obsolete : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ %recruitment, obsolete : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ recruitment rate, moose (aerial surveys) : chr [1:61] &quot;20&quot; &quot;14.3&quot; &quot;19.5&quot; &quot;16.5&quot; ... #R&gt; $ mean age (excluding calves) : chr [1:61] &quot;5.8211920529999999&quot; &quot;6.1446540880000002&quot; &quot;6.266666667&quot; &quot;6.1117647059999998&quot; ... #R&gt; $ proportion of moose population that are senescent: chr [1:61] &quot;6&quot; &quot;6&quot; &quot;7&quot; &quot;7&quot; ... #R&gt; $ UN:C -west : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ UN:C - east : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ GA:C - west : chr [1:61] NA NA NA NA ... #R&gt; $ GA:C - east : chr [1:61] NA NA NA NA ... #R&gt; $ proportion of diet that is fir : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ proportion of diet that is cedar : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ proportion of diet that is deciduous : num [1:61] NA NA NA NA NA NA NA NA NA NA ... #R&gt; $ ticks (mean hair loss) : chr [1:61] NA NA NA NA ... #R&gt; $ July-Sept (temp, F) : chr [1:61] &quot;61.2&quot; &quot;60.667000000000002&quot; &quot;60.966999999999999&quot; &quot;57.9&quot; ... #R&gt; $ Apr-May (temp, F) : num [1:61] 43.9 43.4 41.4 42.6 43.5 ... #R&gt; $ Jan-Feb (temp, F) : num [1:61] 1.4 8.45 9.75 2.15 -0.35 12.4 1.25 1.7 2.75 5.85 ... #R&gt; $ May-Aug (precip, inches) : chr [1:61] &quot;16.8&quot; &quot;12.08&quot; &quot;8.94&quot; &quot;16.010000000000002&quot; ... #R&gt; $ NAO (DJFM - station based) : chr [1:61] &quot;-0.37&quot; &quot;-1.54&quot; &quot;1.8&quot; &quot;-2.38&quot; ... #R&gt; $ NAO - annual : chr [1:61] &quot;1.83&quot; &quot;-1.88&quot; &quot;0.47&quot; &quot;-1.05&quot; ... #R&gt; $ snow.depth (cm) : chr [1:61] NA NA NA NA ... #R&gt; $ ice bridges (0=none, 1 = present) : num [1:61] 0 0 1 1 1 0 1 1 1 1 ... #R&gt; $ springtime growing degree days : chr [1:61] &quot;N/A yet&quot; &quot;N/A yet&quot; &quot;N/A yet&quot; &quot;N/A yet&quot; ... The structure of this file shows that there are many variables, most of which I was not interested in for this demonstration, and the variable names are non-standard (i.e., they contains spaces). Thus, to prepare the data for the graphing course, I wanted to .. reduce the data frame to only the variables that I was interested in, rename the variables to be shorter and in standard format, change the coding of the variable about ice bridges from using 0 and 1 to using the more descriptive and easier to remember no and yes, create an era variable says early for years before 1975, middle for years between 1975 and 2000, and recent for years after 2000, move the era variable to be next to the year variable (for aesthetic reasons), and make sure the data are ordered from earliest to latest year. irmw2 &lt;- irmw %&gt;% select(year,wolves,moose,`Jan-Feb (temp, F)`,`ice bridges (0=none, 1 = present)`) %&gt;% rename(winter_temp=`Jan-Feb (temp, F)`, ice_bridges=`ice bridges (0=none, 1 = present)`) %&gt;% mutate(ice_bridges=plyr::mapvalues(ice_bridges,from=c(0,1),to=c(&quot;no&quot;,&quot;yes&quot;)), era=case_when( year&lt;1975 ~ &quot;early&quot;, year&lt;=2000 ~ &quot;middle&quot;, TRUE ~ &quot;recent&quot; )) %&gt;% relocate(era,.after=year) %&gt;% arrange(year) irmw2 #R&gt; # A tibble: 61 x 6 #R&gt; year era wolves moose winter_temp ice_bridges #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 1959 early 20 538. 1.4 no #R&gt; 2 1960 early 22 564. 8.45 no #R&gt; 3 1961 early 22 572. 9.75 yes #R&gt; 4 1962 early 23 579. 2.15 yes #R&gt; 5 1963 early 20 596. -0.35 yes #R&gt; 6 1964 early 26 620. 12.4 no #R&gt; 7 1965 early 28 634. 1.25 yes #R&gt; 8 1966 early 26 661. 1.7 yes #R&gt; 9 1967 early 22 766. 2.75 yes #R&gt; 10 1968 early 22 848. 5.85 yes #R&gt; # ... with 51 more rows If all columns do not exist in the data frame then an error will occur. These selections are likely not needed because bears is so small; however, they are used here to demonstrate the selection techniques. You will learn this in the next module You will learn this in the next module Along with a wide variety of other data about Wolves and Moose on Isle Royale. You may want to review the purpose of some of these arguments to read_excel() in Section 3.3.2. "],["wrangle-rows.html", "Module 7 Wrangle Rows 7.1 Filtering Rows 7.2 Arranging Rows 7.3 Appending Rows 7.4 Examples in Context", " Module 7 Wrangle Rows The previous module demonstrated methods for wrangling columns or variables in a data frame. In this module, methods to wrangle rows in a data frame are introduced. The primary method of interest here is selecting a smaller subset of rows (i.e., filtering) for further analysis. Again the descriptive examples below will use the bears data frame from Section 3.3.1. bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas These simple examples will also use the pipe operator, %&gt;%, to again help you become more comfortable with its use.   7.1 Filtering Rows Observations or rows can be selected from a data frame with filter(). The directive arguments to filter() are conditional expressions describing which observations from the data frame to maintain. Common operators used in these conditional expressions are in Table 7.1.   Table 7.1: Comparison operators used in filterD() and their results. Note that var generically represents a variable in the original data frame and value is a generic value or level. Both var and val would be replaced with specific items (see examples in main text). Comparison Operator Rows Returned from Original Data Frame var==value All rows where var IS equal to value var!=value All rows where var is NOT equal to value var %in% c(value1,value2) All rows where var IS IN (or one of the) vector of values20 var&gt;value All rows where var is greater than value21 var&gt;=value All rows where var is greater than or equal to value22 var&lt;value All rows where var is less than value23 var&lt;=value All rows where var is less than or equal to value24 condition1,condition2 All rows where BOTH conditions are true condition1 | condition2 All rows where ONE or BOTH conditions are true25   The following are examples of new data frames created from bears. The name of the new data frame (i.e., object left of the assignment operator) can be any valid object name. As demonstrated below, the new data frame should be examined after each filtering to ensure that the data frame actually contains the items that you desire. Only individuals from Bayfield county. bf &lt;- bears %&gt;% filter(loc==&quot;Bayfield&quot;) bf #R&gt; # A tibble: 3 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield Individuals from both Bayfield and Ashland counties. bfash &lt;- bears %&gt;% filter(loc %in% c(&quot;Bayfield&quot;,&quot;Ashland&quot;)) bfash #R&gt; # A tibble: 5 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland Individuals NOT from Bayfield county. bfnotbay &lt;- bears %&gt;% filter(loc != &quot;Bayfield&quot;) bfnotbay #R&gt; # A tibble: 5 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 141 100 Ashland #R&gt; 2 141 95 Ashland #R&gt; 3 150 85 Douglas #R&gt; 4 130. 105 Douglas #R&gt; 5 150 110 Douglas Individuals with a weight greater than 100 kg. gt100 &lt;- bears %&gt;% filter(weight.kg&gt;100) gt100 #R&gt; # A tibble: 3 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 130. 105 Douglas #R&gt; 3 150 110 Douglas Individuals from Douglas County that weighed at least 150 kg. do150 &lt;- bears %&gt;% filter(loc==&quot;Douglas&quot;,weight.kg&gt;=150) do150 #R&gt; # A tibble: 0 x 3 #R&gt; # ... with 3 variables: length.cm &lt;dbl&gt;, weight.kg &lt;dbl&gt;, loc &lt;chr&gt; The last example above illustrates that multiple conditional expressions in filter() are combined as an and operator such that both conditions must be true. Examine the new data frame after filtering to ensure that it contains the data you intended.   7.2 Arranging Rows The arrange() function is used to sort rows based on values in one or more variables. By default sorting is in ascending order. To sort in descending order then wrap the variable name in desc(). If more than one variable is given then the rows are first sorted based on the first variable and then ties in the first variable are sorted based on the second variable. Examples of sorting are shown below. Alphabetically sort bears by location name. bears &lt;- bears %&gt;% arrange(loc) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 141 100 Ashland #R&gt; 2 141 95 Ashland #R&gt; 3 139 110 Bayfield #R&gt; 4 120. 60 Bayfield #R&gt; 5 149 85 Bayfield #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Sort bears from heaviest to lightest. bears &lt;- bears %&gt;% arrange(desc(weight.kg)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 150 110 Douglas #R&gt; 3 130. 105 Douglas #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 149 85 Bayfield #R&gt; 7 150 85 Douglas #R&gt; 8 120. 60 Bayfield Sort bears from heaviest to lightest within each location. bears &lt;- bears %&gt;% arrange(loc,desc(weight.kg)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 141 100 Ashland #R&gt; 2 141 95 Ashland #R&gt; 3 139 110 Bayfield #R&gt; 4 149 85 Bayfield #R&gt; 5 120. 60 Bayfield #R&gt; 6 150 110 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 85 Douglas sort bears by size, first by length and then by weight. bears &lt;- bears %&gt;% arrange(length.cm,weight.kg) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 120. 60 Bayfield #R&gt; 2 130. 105 Douglas #R&gt; 3 139 110 Bayfield #R&gt; 4 141 95 Ashland #R&gt; 5 141 100 Ashland #R&gt; 6 149 85 Bayfield #R&gt; 7 150 85 Douglas #R&gt; 8 150 110 Douglas   7.3 Appending Rows Two data frames can be combined with bind_rows() IF they have the same column names and classes. For example suppose that two other data frames exist  bears2 has more bear information and bobcats has similar information about bobcats. bears2 #R&gt; length.cm weight.kg loc #R&gt; 1 135 100 Iron #R&gt; 2 142 115 Iron #R&gt; 3 143 110 Iron bobcats #R&gt; length.cm weight.kg loc #R&gt; 1 75 6.2 Douglas #R&gt; 2 82 8.1 Douglas #R&gt; 3 71 7.4 Bayfield #R&gt; 4 79 7.6 Douglas The code below appends the bears2 data frame to the bottom of the bears data frame and then, for demonstration purposes, orders the bears by size. newbears &lt;- bind_rows(bears,bears2) %&gt;% arrange(length.cm,weight.kg) newbears #R&gt; # A tibble: 11 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 120. 60 Bayfield #R&gt; 2 130. 105 Douglas #R&gt; 3 135 100 Iron #R&gt; 4 139 110 Bayfield #R&gt; 5 141 95 Ashland #R&gt; 6 141 100 Ashland #R&gt; 7 142 115 Iron #R&gt; 8 143 110 Iron #R&gt; 9 149 85 Bayfield #R&gt; 10 150 85 Douglas #R&gt; 11 150 110 Douglas The same could be done with the bears and bobcats data frames but there will be no way to then tell which observations are for bears and which are for bobcats. This deficiency can be overcome by giving names to the data frames within bind_rows() and giving a variable name to .id= for the new variable that will identify the groups. For example, animals &lt;- bind_rows(&quot;bear&quot;=bears,&quot;bobcat&quot;=bobcats,.id=&quot;animal&quot;) animals #R&gt; # A tibble: 12 x 4 #R&gt; animal length.cm weight.kg loc #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 bear 120. 60 Bayfield #R&gt; 2 bear 130. 105 Douglas #R&gt; 3 bear 139 110 Bayfield #R&gt; 4 bear 141 95 Ashland #R&gt; 5 bear 141 100 Ashland #R&gt; 6 bear 149 85 Bayfield #R&gt; 7 bear 150 85 Douglas #R&gt; 8 bear 150 110 Douglas #R&gt; 9 bobcat 75 6.2 Douglas #R&gt; 10 bobcat 82 8.1 Douglas #R&gt; 11 bobcat 71 7.4 Bayfield #R&gt; 12 bobcat 79 7.6 Douglas Note that more than two data frames can be combined with bind_rows().   7.4 Examples in Context value should be a character, factor, or integer. value must be numeric. value must be numeric. value must be numeric. value must be numeric. Note that this or operator is a vertical line which is typed with the shift-backslash key. "],["groupings.html", "Module 8 Groupings", " Module 8 Groupings "],["dates-and-times.html", "Module 9 Dates and Times", " Module 9 Dates and Times "],["factors.html", "Module 10 Factors", " Module 10 Factors "],["references.html", "References", " References "]]
