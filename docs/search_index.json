[["index.html", "Readings for MTH250 - Data Wrangling Preface Package Needs", " Readings for MTH250 - Data Wrangling Derek H. Ogle 24 Jul 2021 Preface XXX However, there are likely still errors or descriptions that dont make sense. Please feel free to ask questions or post errors on the appropriate channel of the course MS Team. The book highlights definitions and tips in special boxes. Definition: This is a definition. This is a tip. R Code and results are also shown in special boxes. Code in the R box can be copied verbatim from the box with the icon that appears when you hover over the upper right corner of the code box. dat &lt;- c(3,4,5,2,8) mean(dat) #R&gt; [1] 4.4 The material presented in this book can be challenging to master. Please dont hesitate to ask me questions as you have them! Package Needs library(tidyverse) "],["preparation.html", "Module 1 Preparation", " Module 1 Preparation XXX "],["data-structures.html", "Module 2 Data Structures 2.1 Vectors 2.2 Data Classes 2.3 Data Frames 2.4 Tidy Data", " Module 2 Data Structures 2.1 Vectors The vector is the primary unit for storing data in R. You can think of a vector as a set of similar items. Vectors are created in R by combining or concatenating together the individual items into a single set with c(). For example, the code below creates a vector of county names stored in an object called cn (perhaps, short for county names). cn &lt;- c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;) Similarly the code below creates a vector of the population size in four counties stored in an object called pop. pop &lt;- c(15512,15056,43164,5687) Vector: The variable thought to depend upon, be explained by, or be predicted by other variables.   Individual items in a vector can be accessed by following the vectors object name with square brackets that contain the numeric position of the item. For example, the second county in cn and the third population size in pop are extracted below. cn[2] #R&gt; [1] &quot;Bayfield&quot; pop[3] #R&gt; [1] 43164 Multiple items can be accessed by combining their position indices into a vector. cn[c(2,3)] #R&gt; [1] &quot;Bayfield&quot; &quot;Douglas&quot; 2.2 Data Classes Vectors must contain the same type or class of items. There are four main classes of data in R. numeric: Numbers that may have decimals; e.g., 12.3. integer: Numbers that do not have decimals; e.g., 12. character: Words; e.g., Bayfield. logical: Logical that must be either TRUE or FALSE. The primary difference between numeric and integer classes is how the data are stored in memory. For most of our purposes this will be irrelevant, so there is no practical difference between these two classes for our work. However, integer values are entered into a vector by appending the value with an L. nabors &lt;- c(4L,3L,3L,3L) The values in a logical vector must be either TRUE or FALSE. Make sure to note that both of these values are in all capital letters. cheqbay &lt;- c(TRUE,TRUE,FALSE,FALSE)   The class (i.e., type) of data in a vector is found with class(). class(cn) #R&gt; [1] &quot;character&quot; class(pop) #R&gt; [1] &quot;numeric&quot; class(nabors) #R&gt; [1] &quot;integer&quot; class(cheqbay) #R&gt; [1] &quot;logical&quot; A factor is a special class of data where character items are specifically classified as representing groups or levels of items. A vector can be converted to a factor class with factor(). fcn &lt;- factor(cn) fcn #R&gt; [1] Ashland Bayfield Douglas Iron #R&gt; Levels: Ashland Bayfield Douglas Iron class(fcn) #R&gt; [1] &quot;factor&quot; Factors have useful properties that will be discussed in more detail in subsequent modules. As stated above, a vector should consist of items of the same class type. For example, this code does not make sense in most instances. huh &lt;- c(&quot;Ashland&quot;,15512,TRUE,3.65) However, this will not produce an error, though it likely will not be what you want it to be. For example, examine the class of this object. class(huh) #R&gt; [1] &quot;character&quot; R uses hierarchical rules to assign a class for these odd situations. Rather than focusing on these rules it is more beneficial to remember that each vector should be of the same class type. Items in vectors should all be the same class type. 2.3 Data Frames Vectors are useful for small numbers of items that have a single purpose. However, a data frame is more useful if you have multiple types of items (e.g., variables) recorded on a large number of individuals. Here we explore small data frames; larger data frames will be imported from external data sources in Module 3. A data frame is a rectangular data structure where columns are vectors of the same class that represent variables recorded on individuals which are represented in rows. Simple data frames can be constructed with data.frame() with named arguments set equal to vectors of data. For example, the following code produces a data frame object called counties that has three variables called name, pop, and party. counties &lt;- data.frame(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) Type the name of the data frame object to see its contents. counties #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep Columns of data frames correspond to variables whereas rows correspond to individuals. Use str() to examine the structure of the data frame object, which will show that the object is a data.frame, show the number of individuals (label as obs for observations) and variables, and show the name of each column/variable along with its class type abbreviation and a snapshot of the first few items in each row. str(counties) #R&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #R&gt; $ name : chr &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; ... #R&gt; $ pop : num 15512 15056 43164 5687 16746 #R&gt; $ party: chr &quot;Dem&quot; &quot;Dem&quot; &quot;Dem&quot; &quot;Rep&quot; ... As data frames are rectangular, individual items are accessed by using both the row and column positions within square brackets after the data frame object name. counties[1,2] # first row, second column #R&gt; [1] 15512 counties[3,1] # third row, first column #R&gt; [1] &quot;Douglas&quot; Entire rows or columns are accessed by providing the numerical position of the row or column and leaving the other indice blank. counties[1,] # First row #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem counties[,1] # First column #R&gt; [1] &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; &quot;Sawyer&quot; Note that choosing rows or more than one column will return a data frame as it will likely have data of different classes. class(counties[1,]) # one row is a data frame #R&gt; [1] &quot;data.frame&quot; class(counties[,c(1,2)]) # two columns is a data frame #R&gt; [1] &quot;data.frame&quot; However, choosing one column will return a vector of items all of the same class. class(counties[,1]) # one column is a vector #R&gt; [1] &quot;character&quot; As columns are named we can also use the name to access a specific column. counties[,&quot;pop&quot;] #R&gt; [1] 15512 15056 43164 5687 16746 This same column can be accessed by separating the data frame object name from the column name with a $. counties$pop #R&gt; [1] 15512 15056 43164 5687 16746 Again a column is simply a vector so you access single items in this vector in the usual way. counties$pop[3] #R&gt; [1] 43164 A $ is only used to separate a data frame name from the variable name within that data frame. 2.3.1 Tibbles Tibbles are a special form of data frame that was introduced as part of the tidyverse. Tibbles are created using tibble() in the same way that we used data.frame() previously. counties2 &lt;- tibble(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) For most of our purposes a tibble will behave exactly as a data frame. For example, counties2 #R&gt; # A tibble: 5 x 3 #R&gt; name pop party #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep counties2$pop #R&gt; [1] 15512 15056 43164 5687 16746 There are, however, differences between tibbles and data frames as described in this introduction to tibbles. The primary difference that you will notice in this course is that when you examine the contents of a tibble with a larger number of rows, columns, or both. For example the code below converts a data frame from the FSA package into a tibble. tibex &lt;- as_tibble(FSA::WhitefishLC) However, when you try to display the data in this tibble you can see that only first 10 rows and as many columns as will fit on the width of your display are shown. In this case, 141 rows and one variable are not shown as seen in the note at the bottom. tibex #R&gt; # A tibble: 151 x 11 #R&gt; fishID tl scale1 scale2 scaleC finray1 finray2 finrayC otolith1 otolith2 #R&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #R&gt; 1 1 345 3 3 3 3 3 3 3 3 #R&gt; 2 2 334 4 3 4 3 3 3 3 3 #R&gt; 3 3 348 7 5 6 3 3 3 3 3 #R&gt; 4 4 300 4 3 4 3 2 3 3 3 #R&gt; 5 5 330 3 3 3 4 3 4 3 3 #R&gt; 6 6 316 4 4 4 2 3 3 6 5 #R&gt; 7 7 508 6 7 7 6 6 6 9 10 #R&gt; 8 8 475 4 5 5 9 9 9 11 12 #R&gt; 9 9 340 3 3 3 2 3 3 3 4 #R&gt; 10 10 173 1 1 1 2 1 1 1 1 #R&gt; # ... with 141 more rows, and 1 more variable: otolithC &lt;int&gt; We will encounter tibbles in subsequent modules as some tidyverse functions return tibbles by default. A tibble can be converted to a data frame with as.data.frame(). 2.4 Tidy Data Tidy Data was a term introduced here in 2011 to describe a strict data organization that leads to consistency and efficiencies in data analyses. Tidy data is described in more detail here. Data can be organized in different ways. For example, below is the simple data frame from Section 2.3. #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep However, these same data could be organized as below (among other possible organizations). #R&gt; county variable value #R&gt; 1 Ashland pop 15512 #R&gt; 2 Ashland party Dem #R&gt; 3 Bayfield pop 15056 #R&gt; 4 Bayfield party Dem #R&gt; 5 Douglas pop 43164 #R&gt; 6 Douglas party Dem #R&gt; 7 Iron pop 5687 #R&gt; 8 Iron party Rep #R&gt; 9 Sawyer pop 16746 #R&gt; 10 Sawyer party Rep This second data frame is not tidy and is much more difficult to use. Tidy data frames follow three simple rules: Each variable must have its own column. Each individual (or observation) must have its own row. Each value must have its own cell. The original data frame above is tidy. A common challenge when entering data in a tidy format occurs when data is recorded on individuals in separate groups. For example, the following data are methyl mercury levels recorded in mussels from two locations labeled as impacted and reference. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 In this case, you must realize that one observation is a methyl mercury measurement on a mussel AND to which group the mussel belongs. Thus, each observation results in the recording of two variables. For example, the first mussel had a methyl mercury level of 0.011 AND it was at the impacted site. With this understanding these data are entered in a tidy format as follows. mussels &lt;- tibble(loc=c(&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;), merc=c(0.011,0.054,0.056,0.095,0.051,0.077, 0.031,0.040,0.029,0.066,0.018,0.042,0.044)) mussels #R&gt; # A tibble: 13 x 2 #R&gt; loc merc #R&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 impacted 0.011 #R&gt; 2 impacted 0.054 #R&gt; 3 impacted 0.056 #R&gt; 4 impacted 0.095 #R&gt; 5 impacted 0.051 #R&gt; 6 impacted 0.077 #R&gt; 7 reference 0.031 #R&gt; 8 reference 0.04 #R&gt; 9 reference 0.029 #R&gt; 10 reference 0.066 #R&gt; 11 reference 0.018 #R&gt; 12 reference 0.042 #R&gt; 13 reference 0.044 Tidy data will facilitate data wrangling in subsequent modules and data analysis and graphing in other courses. "],["external-data-files.html", "Module 3 External Data Files 3.1 Entering Data 3.2 Saving the External File 3.3 Reading the External File", " Module 3 External Data Files Most realistic data has more than a few individuals and is, thus, not easily entered using data.frame() or tibble() as shown in Section 2.3. Rather these data are often entered and stored in a spreadsheet or database that is external to R and, thus, needs to be read or loaded into R. This module describes how data should be entered into a spreadsheet and then how that data is read into R. 3.1 Entering Data Tidy data (see Section 2.4) is often read into a spreadsheet program such as Microsoft Excel or Google Sheets. The spreadsheet should be organized with variables in columns and individuals in rows, with the exception that the first row should contain variable names. The example spreadsheet below shows the length (cm), weight (kg), and capture location data for a small sample of Black Bears.   Variable names should NOT contain spaces. For example, dont use total length or length (cm). If you feel the need to have longer variable names, then separate the parts with a period (e.g., length.cm) or an underscore (e.g., length_cm). Variable names can NOT start with numbers or contain special characters such as ~, ! &amp;, @, etc. Furthermore, numerical measurements should NOT include units (e.g., dont use 7 cm). Finally, for categorical data, make sure that all categories are consistent (e.g., do not use both bayfield and Bayfield). When entering data make sure to follow the three rules of tidy data (see Section 2.4). For example, the following data are methyl mercury levels recorded in mussels captured from impacted and reference locations. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 As described in Section 2.4, one observation (i.e., row) is a methyl mercury measurement on a mussel AND which group the mussel belongs. The rules for tidy data dictate two columns (one for each of the two variables recorded) and 13 rows (one for each obseration of a mussel). format as follows. Thus, these data would be entered into the spreadsheet as shown below.   3.2 Saving the External File The spreadsheet may be saved in the format of the spreadsheet program (e.g., as an Excel file) to be read into R. However, it is also common to save the file as a comma separated values (CSV) file to be read into R. The advantage of a CSV file is that these files are small and, because they do not require any special software (e.g., Excel) to read, they are very likely to always be able to be read into R. 3.2.1 Excel An Excel worksheet is saved as a CSV file by selecting the File..Save As menu item, which will produce the dialog box below. In this dialog box, change Save as type to CSV (Comma delimited),1, provide a file name (do not put any periods in the name), select a location to save the file (this should be the same location as your assignment template file), and press Save. Two warning dialog boxes may then appear  select OK for the first and YES for the second. You can now close the spreadsheet file.2 3.2.2 Google Sheets A Google Sheet can be made available as a CSV file with the following steps by selecting the File menu, Share submenu, and Publish to web submenu. In the ensuing dialog box, change Entire Document to name of the sheet you want to publish and Web Page to Comma-separated values (.csv) under the Link tab. Then press the Publish button and press OK when asked to confirm publishing. Finally, select and copy (CTRL-C or CMD-C) the entire link shown in the box above. This link will be used as described in the next section. 3.3 Reading the External File 3.3.1 CSV Files CSV files may be read with read.csv() from base R or read_csv() from tidyverse. For most of our applications there will be little functional difference between these two functions. However, read_csv() is faster than read.csv() and can be a little smarter about the way it imports certain columns.3 In addition, it is a bit more transparent about what it is doing. For those reasons, we will use read_csv() in this course. An object saved from read_csv() will be a tibble. The first argument to read_csv() is the filename. This file must exist in your working directory, include be a partial path relative to your working directory or a full path to the file, or be a valid URL. For example, the code below reads Bears.csv from the data folder in my working directory and stores the result in the bears object. Here, I used file.path() to combine the folder names in the partial path with the filename because file.path() creates at path that will be correct for your operating system.4 bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The filename argument could also be the link to the published Google Sheet (from above). bears &lt;- read_csv(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vQaxD9tvwL29MydISlYw4bVXrw6-rvkEbT_2qFGxw7HuYX6M3h83aIYT4eZ-mrrEfJf8y5Q8p1Rkn4Z/pub?gid=522647677&amp;single=true&amp;output=csv&quot;) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The URL does not have to be from the published Google Sheet. For example, the following reads a CSV from this page that lists information about every player who has played in the National Basketball Association (NBA). players &lt;- read_csv(&quot;https://sports-statistics.com/database/basketball-data/nba/NBA-playerlist.csv&quot;) players #R&gt; # A tibble: 4,393 x 15 #R&gt; X1 DISPLAY_FIRST_LAST DISPLAY_LAST_COMMA_FIRST FROM_YEAR GAMES_PLAYED_FL~ #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 0 Alaa Abdelnaby Abdelnaby, Alaa 1990 Y #R&gt; 2 1 Zaid Abdul-Aziz Abdul-Aziz, Zaid 1968 Y #R&gt; 3 2 Kareem Abdul-Jabbar Abdul-Jabbar, Kareem 1969 Y #R&gt; 4 3 Mahmoud Abdul-Rauf Abdul-Rauf, Mahmoud 1990 Y #R&gt; 5 4 Tariq Abdul-Wahad Abdul-Wahad, Tariq 1997 Y #R&gt; 6 5 Shareef Abdur-Rahim Abdur-Rahim, Shareef 1996 Y #R&gt; 7 6 Tom Abernethy Abernethy, Tom 1976 Y #R&gt; 8 7 Forest Able Able, Forest 1956 Y #R&gt; 9 8 John Abramovic Abramovic, John 1946 Y #R&gt; 10 9 Alex Abrines Abrines, Alex 2016 Y #R&gt; # ... with 4,383 more rows, and 10 more variables: #R&gt; # OTHERLEAGUE_EXPERIENCE_CH &lt;chr&gt;, PERSON_ID &lt;dbl&gt;, PLAYERCODE &lt;chr&gt;, #R&gt; # ROSTERSTATUS &lt;dbl&gt;, TEAM_ABBREVIATION &lt;chr&gt;, TEAM_CITY &lt;chr&gt;, #R&gt; # TEAM_CODE &lt;chr&gt;, TEAM_ID &lt;dbl&gt;, TEAM_NAME &lt;chr&gt;, TO_YEAR &lt;dbl&gt;   The read_csv() function provides a variety of options that will help you correctly load CSV files that may be quirky in some respects. Use skip.lines= to skip, for example, the first two lines in a CSV file that do not contain data (perhaps they hold comments). tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_SkipLines.csv&quot;),skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Alternatively, use comment= to identify leading characters that identify lines in the data file that are comments and should not be read as data. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Comment.csv&quot;),comment=&quot;#&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Often data may be missing. By default, R treats NA in the data frame as missing data. If all missing data is coded with NA then read_csv() will handle this properly. For example, note the NAs in the second and eighth rows below. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing1.csv&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; However, some researcher may denote missing data with other codes. For example, the data file read below used - denote missing data. In cases like this, use na= to dictate which codes should be missing and converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing2.csv&quot;),na=&quot;-&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; In other instances, the research may have sloppily used multiple codes for missing data. In these instances, set na= to a vector of all codes to be converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing3.csv&quot;),na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.2 Excel Files Some researchers prefer to save data entered in Excel as an Excel workbook rather than a CSV file. The main argument here is that saving to a CSV often results in two files  an Excel workbook file and a CSV file. It is generally bad practice to have your data in two files as you may update the Excel file and forget to save it to the CSV file or you may update the CSV file and forget to also update the Excel file. Regardless of the reason, data can generally be read from an Excel file into R. The read_excel() function from the readxl package provides a coherent process for reading data from an Excel workbook. The first argument to read_excel() is the name of the Excel file, possibly with path information. By default read_excel() reads the first sheet in the Excel workbook. The example below reads the first sheet of the DataExamples.xlsx workbook in the data folder.5 tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Data on specific sheets can be read by including the sheet name in sheet=. Additionally, lines at the top of the sheet can be skipped with skip= as described for read_csv(). For example, the code below reads the data after the first two lines in the Bears_SkipLines worksheet in the same Excel workbook. tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_SkipLines&quot;,skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Missing data is handled exactly as described for read_csv(). tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_Missing3&quot;,na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   In general, read_excel() works best if the data are arranged rectangularly starting in cell A1. However, read_excel() can handle different organizations of data in the worksheet as described here. Researchers may also use multiple header rows in their Excel worksheet; e.g., variables names in the first row, variable units in the second row. This provides a strategy for reading data arranged in such a way. The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.3 Google Sheets It is also possible to read a file directly from Google Sheets using functions in the googlesheets4 package as described here. Using this package to read directly from Google Sheets requires you to authorize R to access your Google Sheets. 3.3.4 Other Formats Data may be stored in other, less common formats. A rew examples of functions to read these other formats are listed below. read_csv2() (from tidyverse) for fields separated by semi-colons (rather than commas) as is common in Europe. read_tsv() (from tidyverse) for fields separated by tabs (rather than commas). read_fwf() (from tidyverse) for fields that are a fixed width. read_sav() (from haven) for .sav files from SPSS. read_sas() (from haven) for .sas7bdat and .sas7bcat files from SAS. read_dta() (from haven) for .dta files from Stata. There are several choices for CSV files here; do NOT choose the one with UTF-8 in the name. You may be asked to save changes  you should say No. How read_csv() identifies the class of data in a column is described here Windows and Mac OS handle paths differently; this function avoids that complication. I use the readxl::read_excel() construct here rather than loading the readxl package and then simply using read_excel() because this is the only function that I will use from readxl. Thus, I am not loading unneeded functions into my work environment. "],["relational-data.html", "Module 4 Relational Data 4.1 Join Concepts 4.2 Joins in R 4.3 Examples With Context", " Module 4 Relational Data Some situations will have multiple data frames with related data. A particular analysis may require combining these data frames into a single data frame. If the data in the separate data frames are connected by a key variable then the data are said to be relational  i.e., they relate to each other through a common variable (or variables). As an example a college may have the following four data frames with respect to its students. Personal information (hometown, age, etc.) Financial aid information (family income, Pell Grant aid amount, etc.) Academic information (standing, major, gpa, etc.) Current course information (i.e., which courses a students is registered for) Each of these data frames would also contain a student ID variable so that a students personal information can be connect with the students financial aid, academic, or course information. This student ID variable is the key variable for these relational data frames. Data from related data frames can be joined in a variety of ways. This module will explain several types of joins and how to accomplish those joins in R. 4.1 Join Concepts To illustrate the various joins, suppose that a simple data frame x exists that has an id key variable and a val1 measurement variable.6 id val1 101 x1 102 x2 102 x3 103 x4 Further suppose that a second data frame y has the same id key variable and different val2 and val3 measurement variables.7 id val2 val3 101 y1 z1 102 y2 z2 104 y3 z3 104 y4 z4 It is instructive when learning about joins to visualize all combinations of observations in the two data frames.8 As some key variable values may be missing in the data frames we also consider combinations with a missing key variable value (and the measurement variables set to NA), All combinations of the rows in x and y with the missing key values are shown on the left for each join type in the subsections below. 4.1.1 Inner Join An inner join is the simplest join. It returns values from both data frames where the key variable(s) match in both data frames. In our simple data frames an inner join returns the rows from all combinations of rows (see left below) where the id variables (i.e., colors) from x and y match (see center below). The final result is these rows with the duplicated id key variable removed (see right below). All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for inner join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final inner join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 Inner Join: Rows from both data frames where the key variable columns match. 4.1.2 Left Join A left join returns the same rows as an inner join (i.e., all rows where the key variables match) AND all rows from the first data frame that dont have a key variable match in the second data frame. The values for the variables in the second data frame for key values in the first data frame without a match are replaced with NAs. So, a left join will include rows for all key variables from the first data frame, but only rows from the second data frame that had a key variable match with the first data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for left join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final left join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA Left Join: All rows from the first data frame with variables from the second data frame where the key variable columns match (NA otherwise). 4.1.3 Right Join A right join works just like a left join except that the result will include all rows from the second data frame that dont have a key variable match in the first data frame. A right join can also be accomplished with a left join by reversing the order of the two data frames. Right Join: All rows from the second data frame with variables from the first data frame where the key variable columns match (NA otherwise). 4.1.4 Full Join A full join returns the same rows as an inner join (i.e., all rows where the key variable match) AND all rows from each data frame that dont have a key variable match in the other data frame. So a full join will include rows for all key variables from both data frames. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for full join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final full join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA 104 NA y3 z3 104 NA y4 z4 Full Join: All rows from both data frame with variables from the other data frame where the key variable columns match (NA otherwise). 4.1.5 Semi Join In a semi join only values from the first data frame that have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows that had a key variable match in the second data frame. This is the same result as an inner join but without including the variables from the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for semi join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final semi join result id val1 101 x1 102 x2 102 x3 Semi Join: All variables from the first data frame for rows where the key variable column has a match in the second data frame. 4.1.6 Anti Join In an anti join only values from the first data frame that DO NOT have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows without a key variable match in the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for anti join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final anti join result id val1 103 x4 Anti Join: All variables from the first data frame for rows where the key variable column does NOT have a match in the second data frame.   4.2 Joins in R Performing the joins described in the previous section is straightforward with dplyr (part of the tidyverse) using, conveniently enough, inner_join(), left_join(), right_join(), full_join(), semi_join(), and anti_join(). The first two arguments to each of these functions are the two data frames to join. In addition, the name of the key variable should be given, in quotes, to by=.9 The two data frames used in the previous section are created below as objects in R. x &lt;- data.frame(id=c(101,102,102,103),val1=paste0(&quot;x&quot;,1:4)) x #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 #R&gt; 4 103 x4 y &lt;- data.frame(id=c(101,102,104,104),val2=paste0(&quot;y&quot;,1:4),val3=paste0(&quot;z&quot;,1:4)) y #R&gt; id val2 val3 #R&gt; 1 101 y1 z1 #R&gt; 2 102 y2 z2 #R&gt; 3 104 y3 z3 #R&gt; 4 104 y4 z4   The six joins discussed in the previous section are completed below. You should compare the results here to the visual results above. ij &lt;- inner_join(x,y,by=&quot;id&quot;) ij #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 lj &lt;- left_join(x,y,by=&quot;id&quot;) lj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; rj &lt;- right_join(x,y,by=&quot;id&quot;) rj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 104 &lt;NA&gt; y3 z3 #R&gt; 5 104 &lt;NA&gt; y4 z4 rj2 &lt;- left_join(y,x,by=&quot;id&quot;) # right_join as left_join with x &amp; y reversed rj2 #R&gt; id val2 val3 val1 #R&gt; 1 101 y1 z1 x1 #R&gt; 2 102 y2 z2 x2 #R&gt; 3 102 y2 z2 x3 #R&gt; 4 104 y3 z3 &lt;NA&gt; #R&gt; 5 104 y4 z4 &lt;NA&gt; fj &lt;- full_join(x,y,by=&quot;id&quot;) fj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; #R&gt; 5 104 &lt;NA&gt; y3 z3 #R&gt; 6 104 &lt;NA&gt; y4 z4 sj &lt;- semi_join(x,y,by=&quot;id&quot;) sj #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 aj &lt;- anti_join(x,y,by=&quot;id&quot;) aj #R&gt; id val1 #R&gt; 1 103 x4   4.3 Examples With Context The following examples demonstrate different types of joins within fictitious, but realistic, contexts. Please examine each data frame and the joined results carefully to help further understand what each type of join does. 4.3.1 Student Data (One-to-One) In large institutions or in complicated data environments, data about specific individuals may be housed in a variety of departments each of which maintains its own database. Preferably these data sources can be related via a primary key variable, such as a unique student ID number. As an example, suppose that a colleges admissions office maintains a database of personal information about every student at the college. For example it might look like that below for a fictitious five students. personal &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), first_nm=c(&quot;Rolando&quot;,&quot;Catherine&quot;,&quot;James&quot;,&quot;Rachel&quot;,&quot;Esteban&quot;), last_nm=c(&quot;Blackman&quot;,&quot;Johnson&quot;,&quot;Carmichael&quot;,&quot;Brown&quot;,&quot;Perez&quot;), hometown=c(&quot;Windsor&quot;,&quot;Eden Prairie&quot;,&quot;Marion&quot;,&quot;Milwaukee&quot;,&quot;El Paso&quot;), homestate=c(&quot;MI&quot;,&quot;MN&quot;,&quot;IA&quot;,&quot;WI&quot;,&quot;TX&quot;)) personal #R&gt; studentID first_nm last_nm hometown homestate #R&gt; 1 34535 Rolando Blackman Windsor MI #R&gt; 2 45423 Catherine Johnson Eden Prairie MN #R&gt; 3 73424 James Carmichael Marion IA #R&gt; 4 89874 Rachel Brown Milwaukee WI #R&gt; 5 98222 Esteban Perez El Paso TX In addition the financial aid office may have a database of financial aid information. finaid &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), income_cat=c(4,5,3,2,3), pell_elig=c(TRUE,FALSE,TRUE,TRUE,TRUE), work_study=c(TRUE,FALSE,FALSE,FALSE,TRUE)) finaid #R&gt; studentID income_cat pell_elig work_study #R&gt; 1 34535 4 TRUE TRUE #R&gt; 2 45423 5 FALSE FALSE #R&gt; 3 73424 3 TRUE FALSE #R&gt; 4 89874 2 TRUE FALSE #R&gt; 5 98222 3 TRUE TRUE Furthermore the registrars office has a database of academic information. academics &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), standing=c(&quot;FY&quot;,&quot;FY&quot;,&quot;SO&quot;,&quot;SR&quot;,&quot;JR&quot;), major=c(&quot;undecided&quot;,&quot;NRS&quot;,&quot;Biology&quot;,&quot;SCD&quot;,&quot;SCD&quot;), cum_gpa=c(0,0,3.12,3.67,2.89)) academics #R&gt; studentID standing major cum_gpa #R&gt; 1 34535 FY undecided 0.00 #R&gt; 2 45423 FY NRS 0.00 #R&gt; 3 73424 SO Biology 3.12 #R&gt; 4 89874 SR SCD 3.67 #R&gt; 5 98222 JR SCD 2.89 Note how each of these databases has the studentID variable that will serve as the key variable to connect each students information across each of the databases. These databases form what is called a one-to-one relationship because as each observation record in each database can be connected to one and only one observation record in the other databases. In this example, each database would ideally have an entry for every student. These data frames can generally be joined with inner, left, or right joins depending on the purpose. For example, an institutional researcher may want to examine whether student gpa differed between students that were eligible for a Pell Grant or not. In this case, the researcher would join the finaid and academics data frames so that the pell_elig and cum_gpa variables would be in one data frame. tmp &lt;- inner_join(finaid,academics,by=&quot;studentID&quot;) tmp #R&gt; studentID income_cat pell_elig work_study standing major cum_gpa #R&gt; 1 34535 4 TRUE TRUE FY undecided 0.00 #R&gt; 2 45423 5 FALSE FALSE FY NRS 0.00 #R&gt; 3 73424 3 TRUE FALSE SO Biology 3.12 #R&gt; 4 89874 2 TRUE FALSE SR SCD 3.67 #R&gt; 5 98222 3 TRUE TRUE JR SCD 2.89 An inner join was used here because the researcher only wants to include students that are in both databases (i.e., would likely have an entry for both pell_elig and cum_gpa). Note, however, that a left join or a right join would accomplish the same task as long as both databases had entries for every student (i.e., the databases have the same set of students).   Further suppose that academic advisors would like to have the students names attached to these records so that they could reach out to students who could use some help academically. tmp &lt;- inner_join(personal,tmp,by=&quot;studentID&quot;) tmp #R&gt; studentID first_nm last_nm hometown homestate income_cat pell_elig #R&gt; 1 34535 Rolando Blackman Windsor MI 4 TRUE #R&gt; 2 45423 Catherine Johnson Eden Prairie MN 5 FALSE #R&gt; 3 73424 James Carmichael Marion IA 3 TRUE #R&gt; 4 89874 Rachel Brown Milwaukee WI 2 TRUE #R&gt; 5 98222 Esteban Perez El Paso TX 3 TRUE #R&gt; work_study standing major cum_gpa #R&gt; 1 TRUE FY undecided 0.00 #R&gt; 2 FALSE FY NRS 0.00 #R&gt; 3 FALSE SO Biology 3.12 #R&gt; 4 FALSE SR SCD 3.67 #R&gt; 5 TRUE JR SCD 2.89   Continuing with this example, suppose that the registrars office also maintains a database that contains each students current class schedule. schedules &lt;- tibble(studentID=c(34535,34535,34535,34535, 45423,45423,45423,45423,45423, 73424,73424,73424,73424, 89874,89874,89874, 98222,98222,98222,98222), course=c(&quot;MTH107&quot;,&quot;BIO115&quot;,&quot;CHM110&quot;,&quot;IDS101&quot;, &quot;SCD110&quot;,&quot;PSY110&quot;,&quot;MTH140&quot;,&quot;OED212&quot;,&quot;IDS101&quot;, &quot;BIO234&quot;,&quot;CHM220&quot;,&quot;BIO370&quot;,&quot;SCD110&quot;, &quot;SCD440&quot;,&quot;PSY370&quot;,&quot;IDS490&quot;, &quot;SCD440&quot;,&quot;SCD330&quot;,&quot;SOC480&quot;,&quot;ART220&quot;)) schedules #R&gt; # A tibble: 20 x 2 #R&gt; studentID course #R&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 #R&gt; 2 34535 BIO115 #R&gt; 3 34535 CHM110 #R&gt; 4 34535 IDS101 #R&gt; 5 45423 SCD110 #R&gt; 6 45423 PSY110 #R&gt; 7 45423 MTH140 #R&gt; 8 45423 OED212 #R&gt; 9 45423 IDS101 #R&gt; 10 73424 BIO234 #R&gt; 11 73424 CHM220 #R&gt; 12 73424 BIO370 #R&gt; 13 73424 SCD110 #R&gt; 14 89874 SCD440 #R&gt; 15 89874 PSY370 #R&gt; 16 89874 IDS490 #R&gt; 17 98222 SCD440 #R&gt; 18 98222 SCD330 #R&gt; 19 98222 SOC480 #R&gt; 20 98222 ART220 The registrars office also maintains a database of information about every course taught at the college. A partial example of such a database is shown below.10 courses &lt;- tibble(course=c(&quot;ART220&quot;,&quot;ART330&quot;,&quot;BIO115&quot;,&quot;BIO234&quot;,&quot;BIO370&quot;,&quot;BIO490&quot;, &quot;CHM110&quot;,&quot;CHM220&quot;,&quot;CHM360&quot;,&quot;IDS101&quot;,&quot;IDS490&quot;,&quot;MTH107&quot;, &quot;MTH140&quot;,&quot;MTH230&quot;,&quot;OED212&quot;,&quot;OED330&quot;,&quot;OED360&quot;,&quot;PSY110&quot;, &quot;PSY370&quot;,&quot;SCD110&quot;,&quot;SCD330&quot;,&quot;SCD440&quot;,&quot;SOC111&quot;,&quot;SOC480&quot;), credits=c(3,3,4,4,4,4,4,4,4,3,4,4,4,4,3,3,3,4,4,3,3,4,4,4), instructor=c(&quot;Duffy&quot;,&quot;Terry&quot;,&quot;Johnson&quot;,&quot;Goyke&quot;,&quot;Anich&quot;,&quot;Anich&quot;, &quot;Carlson&quot;,&quot;Robertson&quot;,&quot;Carlson&quot;,&quot;Goyke&quot;,&quot;Hannickel&quot;,&quot;Ogle&quot;, &quot;Jensen&quot;,&quot;Jensen&quot;,&quot;Andre&quot;,&quot;Andre&quot;,&quot;Coulson&quot;,&quot;Sneyd&quot;, &quot;Sneyd&quot;,&quot;Tochterman&quot;,&quot;Tochterman&quot;,&quot;Foster&quot;, &quot;Schanning&quot;,&quot;Schanning&quot;)) courses #R&gt; # A tibble: 24 x 3 #R&gt; course credits instructor #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 ART220 3 Duffy #R&gt; 2 ART330 3 Terry #R&gt; 3 BIO115 4 Johnson #R&gt; 4 BIO234 4 Goyke #R&gt; 5 BIO370 4 Anich #R&gt; 6 BIO490 4 Anich #R&gt; 7 CHM110 4 Carlson #R&gt; 8 CHM220 4 Robertson #R&gt; 9 CHM360 4 Carlson #R&gt; 10 IDS101 3 Goyke #R&gt; # ... with 14 more rows These two data frames are related via the common course variable. This type of database organization is particularly useful because the information about any one course only needs to be entered once in courses even though the actual course may appear many times in schedules. This helps save time and reduces data entry errors. It is easy to add the specific course information (credits and instructor) from courses to the students course information in schedules with a left_join(). schedules2 &lt;- left_join(schedules,courses,by=&quot;course&quot;) schedules2 #R&gt; # A tibble: 20 x 4 #R&gt; studentID course credits instructor #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 4 Ogle #R&gt; 2 34535 BIO115 4 Johnson #R&gt; 3 34535 CHM110 4 Carlson #R&gt; 4 34535 IDS101 3 Goyke #R&gt; 5 45423 SCD110 3 Tochterman #R&gt; 6 45423 PSY110 4 Sneyd #R&gt; 7 45423 MTH140 4 Jensen #R&gt; 8 45423 OED212 3 Andre #R&gt; 9 45423 IDS101 3 Goyke #R&gt; 10 73424 BIO234 4 Goyke #R&gt; 11 73424 CHM220 4 Robertson #R&gt; 12 73424 BIO370 4 Anich #R&gt; 13 73424 SCD110 3 Tochterman #R&gt; 14 89874 SCD440 4 Foster #R&gt; 15 89874 PSY370 4 Sneyd #R&gt; 16 89874 IDS490 4 Hannickel #R&gt; 17 98222 SCD440 4 Foster #R&gt; 18 98222 SCD330 3 Tochterman #R&gt; 19 98222 SOC480 4 Schanning #R&gt; 20 98222 ART220 3 Duffy Note here that if we consider schedules as the primary data frame of interest then this relationship is still a one-to-one relationship because each course in schedules can be connected to only one course record in courses.   The students personal information can also be added to these results with a left_join() but now using the studentID key variable. schedules2 &lt;- left_join(personal,schedules2,by=&quot;studentID&quot;) schedules2 #R&gt; studentID first_nm last_nm hometown homestate course credits #R&gt; 1 34535 Rolando Blackman Windsor MI MTH107 4 #R&gt; 2 34535 Rolando Blackman Windsor MI BIO115 4 #R&gt; 3 34535 Rolando Blackman Windsor MI CHM110 4 #R&gt; 4 34535 Rolando Blackman Windsor MI IDS101 3 #R&gt; 5 45423 Catherine Johnson Eden Prairie MN SCD110 3 #R&gt; 6 45423 Catherine Johnson Eden Prairie MN PSY110 4 #R&gt; 7 45423 Catherine Johnson Eden Prairie MN MTH140 4 #R&gt; 8 45423 Catherine Johnson Eden Prairie MN OED212 3 #R&gt; 9 45423 Catherine Johnson Eden Prairie MN IDS101 3 #R&gt; 10 73424 James Carmichael Marion IA BIO234 4 #R&gt; 11 73424 James Carmichael Marion IA CHM220 4 #R&gt; 12 73424 James Carmichael Marion IA BIO370 4 #R&gt; 13 73424 James Carmichael Marion IA SCD110 3 #R&gt; 14 89874 Rachel Brown Milwaukee WI SCD440 4 #R&gt; 15 89874 Rachel Brown Milwaukee WI PSY370 4 #R&gt; 16 89874 Rachel Brown Milwaukee WI IDS490 4 #R&gt; 17 98222 Esteban Perez El Paso TX SCD440 4 #R&gt; 18 98222 Esteban Perez El Paso TX SCD330 3 #R&gt; 19 98222 Esteban Perez El Paso TX SOC480 4 #R&gt; 20 98222 Esteban Perez El Paso TX ART220 3 #R&gt; instructor #R&gt; 1 Ogle #R&gt; 2 Johnson #R&gt; 3 Carlson #R&gt; 4 Goyke #R&gt; 5 Tochterman #R&gt; 6 Sneyd #R&gt; 7 Jensen #R&gt; 8 Andre #R&gt; 9 Goyke #R&gt; 10 Goyke #R&gt; 11 Robertson #R&gt; 12 Anich #R&gt; 13 Tochterman #R&gt; 14 Foster #R&gt; 15 Sneyd #R&gt; 16 Hannickel #R&gt; 17 Foster #R&gt; 18 Tochterman #R&gt; 19 Schanning #R&gt; 20 Duffy These data frames represents a one-to-many relationship because studentID in personal is connected to many studentID records in schedules2 (one for each course the student is enrolled in).   4.3.2 Resource Sampling Data (One-to-Many Relationship) In sampling of natural resources it is common to have one database for information about the unit of sampling and another database specific to items within that sampling unit. For example, in fisheries we may have one database to record information about a particular net (e.g., where it is located, the date it was set) and a second database that records the species of fish caught and number of the species caught. You may be tempted to do this all in one database with a separate field for each fish species but this is inefficient as you may not know which species you may catch. Thus, every time you catch a new species you would need to add a new field or column to your database. In addition, this would be highly inefficient if you were to record information about individual fish (e.g., length and weight) as the amount of this information may vary from net to net. In this simple example, information about five specific settings of a net is stored in nets, which has a unique identifier for each net setting called net_num. nets &lt;- data.frame(net_num=1:5, lake=c(&quot;Eagle&quot;,&quot;Hart&quot;,&quot;Hart&quot;,&quot;Eagle&quot;,&quot;Millicent&quot;), date=c(&quot;3-Jul-21&quot;,&quot;3-Jul-21&quot;,&quot;5-Jul-21&quot;,&quot;6-Jul-21&quot;,&quot;6-Jul-21&quot;)) nets #R&gt; net_num lake date #R&gt; 1 1 Eagle 3-Jul-21 #R&gt; 2 2 Hart 3-Jul-21 #R&gt; 3 3 Hart 5-Jul-21 #R&gt; 4 4 Eagle 6-Jul-21 #R&gt; 5 5 Millicent 6-Jul-21 In a separate data frame the researchers recorded the species and number of each species caught in each net. Here there is a separate row for each species and its number caught with each row indexed to the specific net with the net_num key variable. catch &lt;- data.frame(net_num=c(1,1,2,2,2,4,4,5), species=c(&quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;,&quot;Bluntnose Minnow&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Largemouth Bass&quot;), number=c(7,3,19,2,56,3,6,3)) catch #R&gt; net_num species number #R&gt; 1 1 Bluegill 7 #R&gt; 2 1 Largemouth Bass 3 #R&gt; 3 2 Bluegill 19 #R&gt; 4 2 Largemouth Bass 2 #R&gt; 5 2 Bluntnose Minnow 56 #R&gt; 6 4 Bluegill 3 #R&gt; 7 4 Largemouth Bass 6 #R&gt; 8 5 Largemouth Bass 3 These data frames illustrate a one-to-many relationship as each record in nets may be connected to multiple records in catch. The catch data will be joined to the net data using a left_join() because it is important to keep track of nets that also did not catch fish. An inner_join() would only return nets where some fish were caught. fishcatch &lt;- left_join(nets,catch,by=&quot;net_num&quot;) fishcatch #R&gt; net_num lake date species number #R&gt; 1 1 Eagle 3-Jul-21 Bluegill 7 #R&gt; 2 1 Eagle 3-Jul-21 Largemouth Bass 3 #R&gt; 3 2 Hart 3-Jul-21 Bluegill 19 #R&gt; 4 2 Hart 3-Jul-21 Largemouth Bass 2 #R&gt; 5 2 Hart 3-Jul-21 Bluntnose Minnow 56 #R&gt; 6 3 Hart 5-Jul-21 &lt;NA&gt; NA #R&gt; 7 4 Eagle 6-Jul-21 Bluegill 3 #R&gt; 8 4 Eagle 6-Jul-21 Largemouth Bass 6 #R&gt; 9 5 Millicent 6-Jul-21 Largemouth Bass 3 The visualizations in this section are modified from https://twitter.com/hadleywickham/status/684407629259526148/photo/1. In this treatment, the unique id values are also uniquely color coded to help track individual observations in the descriptions below. Finding all combinations, however, is not needed to actually join two data frames. If by= is not explicitly set by the user then the two data frames will be joined using the variable(s) that the two data frames have in common for by=. A message will be displayed about which variable(s) was used; check this message carefully to make sure you are joining by the variables that you want to join by. I switched to using tibble() in the last two data frams only so that they may potentially print in a more concise manner. "],["pivoting.html", "Module 5 Pivoting 5.1 Pivoting Concepts 5.2 Pivoting in R 5.3 Examples with Context", " Module 5 Pivoting 5.1 Pivoting Concepts 5.2 Pivoting in R 5.3 Examples with Context "],["references.html", "References", " References "]]
