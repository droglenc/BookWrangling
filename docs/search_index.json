[["index.html", "Readings for MTH250 - Data Wrangling Preface Package Needs", " Readings for MTH250 - Data Wrangling Derek H. Ogle 22 Jul 2021 Preface XXX However, there are likely still errors or descriptions that dont make sense. Please feel free to ask questions or post errors on the appropriate channel of the course MS Team. The book highlights definitions and tips in special boxes. Definition: This is a definition. This is a tip. R Code and results are also shown in special boxes. Code in the R box can be copied verbatim from the box with the icon that appears when you hover over the upper right corner of the code box. dat &lt;- c(3,4,5,2,8) mean(dat) #R&gt; [1] 4.4 The material presented in this book can be challenging to master. Please dont hesitate to ask me questions as you have them! Package Needs library(tidyverse) "],["preparation.html", "Module 1 Preparation", " Module 1 Preparation XXX "],["data-structures.html", "Module 2 Data Structures 2.1 Vectors 2.2 Data Classes 2.3 Data Frames 2.4 Tidy Data", " Module 2 Data Structures 2.1 Vectors The vector is the primary unit for storing data in R. You can think of a vector as a set of similar items. Vectors are created in R by combining or concatenating together the individual items into a single set with c(). For example, the code below creates a vector of county names stored in an object called cn (perhaps, short for county names). cn &lt;- c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;) Similarly the code below creates a vector of the population size in four counties stored in an object called pop. pop &lt;- c(15512,15056,43164,5687) Vector: The variable thought to depend upon, be explained by, or be predicted by other variables. Â  Individual items in a vector can be accessed by following the vectors object name with square brackets that contain the numeric position of the item. For example, the second county in cn and the third population size in pop are extracted below. cn[2] #R&gt; [1] &quot;Bayfield&quot; pop[3] #R&gt; [1] 43164 Multiple items can be accessed by combining their position indices into a vector. cn[c(2,3)] #R&gt; [1] &quot;Bayfield&quot; &quot;Douglas&quot; 2.2 Data Classes Vectors must contain the same type or class of items. There are four main classes of data in R. numeric: Numbers that may have decimals; e.g., 12.3. integer: Numbers that do not have decimals; e.g., 12.1 character: Words; e.g., Bayfield. logical: Logical that must be either TRUE or FALSE. The class (i.e., type) of data in a vector is found with class(). class(cn) #R&gt; [1] &quot;character&quot; class(pop) #R&gt; [1] &quot;numeric&quot; A factor is a special class of data where character items are specifically classified as representing groups or levels of items. A vector can be converted to a factor class with factor(). fcn &lt;- factor(cn) fcn #R&gt; [1] Ashland Bayfield Douglas Iron #R&gt; Levels: Ashland Bayfield Douglas Iron class(fcn) #R&gt; [1] &quot;factor&quot; Factors have useful properties that will be discussed in more detail in subsequent modules. As stated above, a vector should consist of items of the same class type. For example, this code does not make sense in most instances. huh &lt;- c(&quot;Ashland&quot;,15512,TRUE,3.65) However, this will not produce an error, though it likely will not be what you want it to be. For example, examine the class of this object. class(huh) #R&gt; [1] &quot;character&quot; R uses hierarchical rules to assign a class for these odd situations. Rather than focusing on these rules it is more beneficial to remember that each vector should be of the same class type. Items in vectors should all be the same class type. 2.3 Data Frames Vectors are useful for small numbers of items that have a single purpose. However, a data frame is more useful if you have multiple types of items (e.g., variables) recorded on a large number of individuals. Here we explore small data frames; larger data frames will be imported from external data sources in Module 3. A data frame is a rectangular data structure where columns are vectors of the same class that represent variables recorded on individuals which are represented in rows. Simple data frames can be constructed with data.frame() with named arguments set equal to vectors of data. For example, the following code produces a data frame object called counties that has three variables called name, pop, and party. counties &lt;- data.frame(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) Type the name of the data frame object to see its contents. counties #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep Columns of data frames correspond to variables whereas rows correspond to individuals. Use str() to examine the structure of the data frame object, which will show that the object is a data.frame, show the number of individuals (label as obs for observations) and variables, and show the name of each column/variable along with its class type abbreviation and a snapshot of the first few items in each row. str(counties) #R&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #R&gt; $ name : chr &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; ... #R&gt; $ pop : num 15512 15056 43164 5687 16746 #R&gt; $ party: chr &quot;Dem&quot; &quot;Dem&quot; &quot;Dem&quot; &quot;Rep&quot; ... As data frames are rectangular, individual items are accessed by using both the row and column positions within square brackets after the data frame object name. counties[1,2] # first row, second column #R&gt; [1] 15512 counties[3,1] # third row, first column #R&gt; [1] &quot;Douglas&quot; Entire rows or columns are accessed by providing the numerical position of the row or column and leaving the other indice blank. counties[1,] # First row #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem counties[,1] # First column #R&gt; [1] &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; &quot;Sawyer&quot; Note that choosing rows or more than one column will return a data frame as it will likely have data of different classes. class(counties[1,]) # one row is a data frame #R&gt; [1] &quot;data.frame&quot; class(counties[,c(1,2)]) # two columns is a data frame #R&gt; [1] &quot;data.frame&quot; However, choosing one column will return a vector of items all of the same class. class(counties[,1]) # one column is a vector #R&gt; [1] &quot;character&quot; As columns are named we can also use the name to access a specific column. counties[,&quot;pop&quot;] #R&gt; [1] 15512 15056 43164 5687 16746 This same column can be accessed by separating the data frame object name from the column name with a $. counties$pop #R&gt; [1] 15512 15056 43164 5687 16746 Again a column is simply a vector so you access single items in this vector in the usual way. counties$pop[3] #R&gt; [1] 43164 A $ is only used to separate a data frame name from the variable name within that data frame. 2.3.1 Tibbles Tibbles are a special form of data frame that was introduced as part of the tidyverse. Tibbles are created using tibble() in the same way that we used data.frame() previously. counties2 &lt;- tibble(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) For most of our purposes a tibble will behave exactly as a data frame. For example, counties2 #R&gt; # A tibble: 5 x 3 #R&gt; name pop party #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep counties2$pop #R&gt; [1] 15512 15056 43164 5687 16746 There are, however, differences between tibbles and data frames as described in this introduction to tibbles. The primary difference that you will notice in this course is that when you examine the contents of a tibble with a larger number of rows, columns, or both. For example the code below converts a data frame from the FSA package into a tibble. tibex &lt;- as_tibble(FSA::WhitefishLC) However, when you try to display the data in this tibble you can see that only first 10 rows and as many columns as will fit on the width of your display are shown. In this case, 141 rows and one variable are not shown as seen in the note at the bottom. tibex #R&gt; # A tibble: 151 x 11 #R&gt; fishID tl scale1 scale2 scaleC finray1 finray2 finrayC otolith1 otolith2 #R&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #R&gt; 1 1 345 3 3 3 3 3 3 3 3 #R&gt; 2 2 334 4 3 4 3 3 3 3 3 #R&gt; 3 3 348 7 5 6 3 3 3 3 3 #R&gt; 4 4 300 4 3 4 3 2 3 3 3 #R&gt; 5 5 330 3 3 3 4 3 4 3 3 #R&gt; 6 6 316 4 4 4 2 3 3 6 5 #R&gt; 7 7 508 6 7 7 6 6 6 9 10 #R&gt; 8 8 475 4 5 5 9 9 9 11 12 #R&gt; 9 9 340 3 3 3 2 3 3 3 4 #R&gt; 10 10 173 1 1 1 2 1 1 1 1 #R&gt; # ... with 141 more rows, and 1 more variable: otolithC &lt;int&gt; We will encounter tibbles in subsequent modules as some tidyverse functions return tibbles by default. A tibble can be converted to a data frame with as.data.frame(). 2.4 Tidy Data Tidy Data was a term introduced here in 2011 to describe a strict data organization that leads to consistency and efficiencies in data analyses. Tidy data is described in more detail here. Data can be organized in different ways. For example, below is the simple data frame from Section 2.3. #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep However, these same data could be organized as below (among other possible organizations). #R&gt; county variable value #R&gt; 1 Ashland pop 15512 #R&gt; 2 Ashland party Dem #R&gt; 3 Bayfield pop 15056 #R&gt; 4 Bayfield party Dem #R&gt; 5 Douglas pop 43164 #R&gt; 6 Douglas party Dem #R&gt; 7 Iron pop 5687 #R&gt; 8 Iron party Rep #R&gt; 9 Sawyer pop 16746 #R&gt; 10 Sawyer party Rep This second data frame is not tidy and is much more difficult to use. Tidy data frames follow three simple rules: Each variable must have its own column. Each individual (or observation) must have its own row. Each value must have its own cell. The original data frame above is tidy. A common challenge when entering data in a tidy format occurs when data is recorded on individuals in separate groups. For example, the following data are methyl mercury levels recorded in mussels from two locations labeled as impacted and reference. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 In this case, you must realize that one observation is a methyl mercury measurement on a mussel AND to which group the mussel belongs. Thus, each observation results in the recording of two variables. For example, the first mussel had a methyl mercury level of 0.011 AND it was at the impacted site. With this understanding these data are entered in a tidy format as follows. mussels &lt;- tibble(loc=c(&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;), merc=c(0.011,0.054,0.056,0.095,0.051,0.077, 0.031,0.040,0.029,0.066,0.018,0.042,0.044)) mussels #R&gt; # A tibble: 13 x 2 #R&gt; loc merc #R&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 impacted 0.011 #R&gt; 2 impacted 0.054 #R&gt; 3 impacted 0.056 #R&gt; 4 impacted 0.095 #R&gt; 5 impacted 0.051 #R&gt; 6 impacted 0.077 #R&gt; 7 reference 0.031 #R&gt; 8 reference 0.04 #R&gt; 9 reference 0.029 #R&gt; 10 reference 0.066 #R&gt; 11 reference 0.018 #R&gt; 12 reference 0.042 #R&gt; 13 reference 0.044 Tidy data will facilitate data wrangling in subsequent modules and data analysis and graphing in other courses. The primary difference between numeric and integer classes is how the data are stored in memory. For most of our purposes this will be irrelevant, so there is no practical difference between these two classes for our work. "],["external-data-files.html", "Module 3 External Data Files 3.1 Entering Data 3.2 Saving the External File 3.3 Reading the External File", " Module 3 External Data Files Most realistic data has more than a few individuals and is, thus, not easily entered using data.frame() or tibble() as shown in Section 2.3. Rather these data are often entered and stored in a spreadsheet or database that is external to R and, thus, needs to be read or loaded into R. This module describes how data should be entered into a spreadsheet and then how that data is read into R. 3.1 Entering Data Tidy data (see Section 2.4) is often read into a spreadsheet program such as Microsoft Excel or Google Sheets. The spreadsheet should be organized with variables in columns and individuals in rows, with the exception that the first row should contain variable names. The example spreadsheet below shows the length (cm), weight (kg), and capture location data for a small sample of Black Bears. Â  Variable names should NOT contain spaces. For example, dont use total length or length (cm). If you feel the need to have longer variable names, then separate the parts with a period (e.g., length.cm) or an underscore (e.g., length_cm). Variable names can NOT start with numbers or contain special characters such as ~, ! &amp;, @, etc. Furthermore, numerical measurements should NOT include units (e.g., dont use 7 cm). Finally, for categorical data, make sure that all categories are consistent (e.g., do not use both bayfield and Bayfield). When entering data make sure to follow the three rules of tidy data (see Section 2.4). For example, the following data are methyl mercury levels recorded in mussels captured from impacted and reference locations. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 As described in Section 2.4, one observation (i.e., row) is a methyl mercury measurement on a mussel AND which group the mussel belongs. The rules for tidy data dictate two columns (one for each of the two variables recorded) and 13 rows (one for each obseration of a mussel). format as follows. Thus, these data would be entered into the spreadsheet as shown below. Â  3.2 Saving the External File The spreadsheet may be saved in the format of the spreadsheet program (e.g., as an Excel file) to be read into R. However, it is also common to save the file as a comma separated values (CSV) file to be read into R. The advantage of a CSV file is that these files are small and, because they do not require any special software (e.g., Excel) to read, they are very likely to always be able to be read into R. 3.2.1 Excel An Excel worksheet is saved as a CSV file by selecting the File..Save As menu item, which will produce the dialog box below. In this dialog box, change Save as type to CSV (Comma delimited),2, provide a file name (do not put any periods in the name), select a location to save the file (this should be the same location as your assignment template file), and press Save. Two warning dialog boxes may then appear  select OK for the first and YES for the second. You can now close the spreadsheet file.3 3.2.2 Google Sheets A Google Sheet can be made available as a CSV file with the following steps by selecting the File menu, Share submenu, and Publish to web submenu. In the ensuing dialog box, change Entire Document to name of the sheet you want to publish and Web Page to Comma-separated values (.csv) under the Link tab. Then press the Publish button and press OK when asked to confirm publishing. Finally, select and copy (CTRL-C or CMD-C) the entire link shown in the box above. This link will be used as described in the next section. 3.3 Reading the External File 3.3.1 CSV Files CSV files may be read with read.csv() from base R or read_csv() from tidyverse. For most of our applications there will be little functional difference between these two functions. However, read_csv() is faster than read.csv() and can be a little smarter about the way it imports certain columns.4 In addition, it is a bit more transparent about what it is doing. For those reasons, we will use read_csv() in this course. An object saved from read_csv() will be a tibble. The first argument to read_csv() is the filename. This file must exist in your working directory, include be a partial path relative to your working directory or a full path to the file, or be a valid URL. For example, the code below reads Bears.csv from the data folder in my working directory and stores the result in the bears object. Here, I used file.path() to combine the folder names in the partial path with the filename because file.path() creates at path that will be correct for your operating system.5 bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The filename argument could also be the link to the published Google Sheet (from above). bears &lt;- read_csv(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vQaxD9tvwL29MydISlYw4bVXrw6-rvkEbT_2qFGxw7HuYX6M3h83aIYT4eZ-mrrEfJf8y5Q8p1Rkn4Z/pub?gid=522647677&amp;single=true&amp;output=csv&quot;) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The URL does not have to be from the published Google Sheet. For example, the following reads a CSV from this page that lists information about every player who has played in the National Basketball Association (NBA). players &lt;- read_csv(&quot;https://sports-statistics.com/database/basketball-data/nba/NBA-playerlist.csv&quot;) players #R&gt; # A tibble: 4,393 x 15 #R&gt; X1 DISPLAY_FIRST_LAST DISPLAY_LAST_COMMA_FIRST FROM_YEAR GAMES_PLAYED_FL~ #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 0 Alaa Abdelnaby Abdelnaby, Alaa 1990 Y #R&gt; 2 1 Zaid Abdul-Aziz Abdul-Aziz, Zaid 1968 Y #R&gt; 3 2 Kareem Abdul-Jabbar Abdul-Jabbar, Kareem 1969 Y #R&gt; 4 3 Mahmoud Abdul-Rauf Abdul-Rauf, Mahmoud 1990 Y #R&gt; 5 4 Tariq Abdul-Wahad Abdul-Wahad, Tariq 1997 Y #R&gt; 6 5 Shareef Abdur-Rahim Abdur-Rahim, Shareef 1996 Y #R&gt; 7 6 Tom Abernethy Abernethy, Tom 1976 Y #R&gt; 8 7 Forest Able Able, Forest 1956 Y #R&gt; 9 8 John Abramovic Abramovic, John 1946 Y #R&gt; 10 9 Alex Abrines Abrines, Alex 2016 Y #R&gt; # ... with 4,383 more rows, and 10 more variables: #R&gt; # OTHERLEAGUE_EXPERIENCE_CH &lt;chr&gt;, PERSON_ID &lt;dbl&gt;, PLAYERCODE &lt;chr&gt;, #R&gt; # ROSTERSTATUS &lt;dbl&gt;, TEAM_ABBREVIATION &lt;chr&gt;, TEAM_CITY &lt;chr&gt;, #R&gt; # TEAM_CODE &lt;chr&gt;, TEAM_ID &lt;dbl&gt;, TEAM_NAME &lt;chr&gt;, TO_YEAR &lt;dbl&gt; Â  The read_csv() function provides a variety of options that will help you correctly load CSV files that may be quirky in some respects. Use skip.lines= to skip, for example, the first two lines in a CSV file that do not contain data (perhaps they hold comments). tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_SkipLines.csv&quot;),skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Alternatively, use comment= to identify leading characters that identify lines in the data file that are comments and should not be read as data. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Comment.csv&quot;),comment=&quot;#&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Often data may be missing. By default, R treats NA in the data frame as missing data. If all missing data is coded with NA then read_csv() will handle this properly. For example, note the NAs in the second and eighth rows below. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing1.csv&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; However, some researcher may denote missing data with other codes. For example, the data file read below used - denote missing data. In cases like this, use na= to dictate which codes should be missing and converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing2.csv&quot;),na=&quot;-&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; In other instances, the research may have sloppily used multiple codes for missing data. In these instances, set na= to a vector of all codes to be converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing3.csv&quot;),na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; Â  The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.2 Excel Files Some researchers prefer to save data entered in Excel as an Excel workbook rather than a CSV file. The main argument here is that saving to a CSV often results in two files  an Excel workbook file and a CSV file. It is generally bad practice to have your data in two files as you may update the Excel file and forget to save it to the CSV file or you may update the CSV file and forget to also update the Excel file. Regardless of the reason, data can generally be read from an Excel file into R. The read_excel() function from the readxl package provides a coherent process for reading data from an Excel workbook. The first argument to read_excel() is the name of the Excel file, possibly with path information. By default read_excel() reads the first sheet in the Excel workbook. The example below reads the first sheet of the DataExamples.xlsx workbook in the data folder.6 tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Data on specific sheets can be read by including the sheet name in sheet=. Additionally, lines at the top of the sheet can be skipped with skip= as described for read_csv(). For example, the code below reads the data after the first two lines in the Bears_SkipLines worksheet in the same Excel workbook. tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_SkipLines&quot;,skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Missing data is handled exactly as described for read_csv(). tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_Missing3&quot;,na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; Â  In general, read_excel() works best if the data are arranged rectangularly starting in cell A1. However, read_excel() can handle different organizations of data in the worksheet as described here. Researchers may also use multiple header rows in their Excel worksheet; e.g., variables names in the first row, variable units in the second row. This provides a strategy for reading data arranged in such a way. The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.3 Google Sheets It is also possible to read a file directly from Google Sheets using functions in the googlesheets4 package as described here. Using this package to read directly from Google Sheets requires you to authorize R to access your Google Sheets. 3.3.4 Other Formats Data may be stored in other, less common formats. A rew examples of functions to read these other formats are listed below. read_csv2() (from tidyverse) for fields separated by semi-colons (rather than commas) as is common in Europe. read_tsv() (from tidyverse) for fields separated by tabs (rather than commas). read_fwf() (from tidyverse) for fields that are a fixed width. read_sav() (from haven) for .sav files from SPSS. read_sas() (from haven) for .sas7bdat and .sas7bcat files from SAS. read_dta() (from haven) for .dta files from Stata. There are several choices for CSV files here; do NOT choose the one with UTF-8 in the name. You may be asked to save changes  you should say No. How read_csv() identifies the class of data in a column is described here Windows and Mac OS handle paths differently; this function avoids that complication. I use the readxl::read_excel() construct here rather than loading the readxl package and then simply using read_excel() because this is the only function that I will use from readxl. Thus, I am not loading unneeded functions into my work environment. "],["references.html", "References", " References "]]
