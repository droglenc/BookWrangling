[["index.html", "Readings for MTH250 - Data Wrangling Preface Package Needs", " Readings for MTH250 - Data Wrangling Derek H. Ogle 25 Jul 2021 Preface XXX However, there are likely still errors or descriptions that dont make sense. Please feel free to ask questions or post errors on the appropriate channel of the course MS Team. The book highlights definitions and tips in special boxes. Definition: This is a definition. This is a tip. R Code and results are also shown in special boxes. Code in the R box can be copied verbatim from the box with the icon that appears when you hover over the upper right corner of the code box. dat &lt;- c(3,4,5,2,8) mean(dat) #R&gt; [1] 4.4 The material presented in this book can be challenging to master. Please dont hesitate to ask me questions as you have them! Package Needs library(tidyverse) "],["preparation.html", "Module 1 Preparation", " Module 1 Preparation XXX "],["data-structures.html", "Module 2 Data Structures 2.1 Vectors 2.2 Data Classes 2.3 Data Frames 2.4 Tidy Data", " Module 2 Data Structures 2.1 Vectors The vector is the primary unit for storing data in R. You can think of a vector as a set of similar items. Vectors are created in R by combining or concatenating together the individual items into a single set with c(). For example, the code below creates a vector of county names stored in an object called cn (perhaps, short for county names). cn &lt;- c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;) Similarly the code below creates a vector of the population size in four counties stored in an object called pop. pop &lt;- c(15512,15056,43164,5687) Vector: The variable thought to depend upon, be explained by, or be predicted by other variables.   Individual items in a vector can be accessed by following the vectors object name with square brackets that contain the numeric position of the item. For example, the second county in cn and the third population size in pop are extracted below. cn[2] #R&gt; [1] &quot;Bayfield&quot; pop[3] #R&gt; [1] 43164 Multiple items can be accessed by combining their position indices into a vector. cn[c(2,3)] #R&gt; [1] &quot;Bayfield&quot; &quot;Douglas&quot; 2.2 Data Classes Vectors must contain the same type or class of items. There are four main classes of data in R. numeric: Numbers that may have decimals; e.g., 12.3. integer: Numbers that do not have decimals; e.g., 12. character: Words; e.g., Bayfield. logical: Logical that must be either TRUE or FALSE. The primary difference between numeric and integer classes is how the data are stored in memory. For most of our purposes this will be irrelevant, so there is no practical difference between these two classes for our work. However, integer values are entered into a vector by appending the value with an L. nabors &lt;- c(4L,3L,3L,3L) The values in a logical vector must be either TRUE or FALSE. Make sure to note that both of these values are in all capital letters. cheqbay &lt;- c(TRUE,TRUE,FALSE,FALSE)   The class (i.e., type) of data in a vector is found with class(). class(cn) #R&gt; [1] &quot;character&quot; class(pop) #R&gt; [1] &quot;numeric&quot; class(nabors) #R&gt; [1] &quot;integer&quot; class(cheqbay) #R&gt; [1] &quot;logical&quot; A factor is a special class of data where character items are specifically classified as representing groups or levels of items. A vector can be converted to a factor class with factor(). fcn &lt;- factor(cn) fcn #R&gt; [1] Ashland Bayfield Douglas Iron #R&gt; Levels: Ashland Bayfield Douglas Iron class(fcn) #R&gt; [1] &quot;factor&quot; Factors have useful properties that will be discussed in more detail in subsequent modules. As stated above, a vector should consist of items of the same class type. For example, this code does not make sense in most instances. huh &lt;- c(&quot;Ashland&quot;,15512,TRUE,3.65) However, this will not produce an error, though it likely will not be what you want it to be. For example, examine the class of this object. class(huh) #R&gt; [1] &quot;character&quot; R uses hierarchical rules to assign a class for these odd situations. Rather than focusing on these rules it is more beneficial to remember that each vector should be of the same class type. Items in vectors should all be the same class type. 2.3 Data Frames Vectors are useful for small numbers of items that have a single purpose. However, a data frame is more useful if you have multiple types of items (e.g., variables) recorded on a large number of individuals. Here we explore small data frames; larger data frames will be imported from external data sources in Module 3. A data frame is a rectangular data structure where columns are vectors of the same class that represent variables recorded on individuals which are represented in rows. Simple data frames can be constructed with data.frame() with named arguments set equal to vectors of data. For example, the following code produces a data frame object called counties that has three variables called name, pop, and party. counties &lt;- data.frame(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) Type the name of the data frame object to see its contents. counties #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep Columns of data frames correspond to variables whereas rows correspond to individuals. Use str() to examine the structure of the data frame object, which will show that the object is a data.frame, show the number of individuals (label as obs for observations) and variables, and show the name of each column/variable along with its class type abbreviation and a snapshot of the first few items in each row. str(counties) #R&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #R&gt; $ name : chr &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; ... #R&gt; $ pop : num 15512 15056 43164 5687 16746 #R&gt; $ party: chr &quot;Dem&quot; &quot;Dem&quot; &quot;Dem&quot; &quot;Rep&quot; ... As data frames are rectangular, individual items are accessed by using both the row and column positions within square brackets after the data frame object name. counties[1,2] # first row, second column #R&gt; [1] 15512 counties[3,1] # third row, first column #R&gt; [1] &quot;Douglas&quot; Entire rows or columns are accessed by providing the numerical position of the row or column and leaving the other indice blank. counties[1,] # First row #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem counties[,1] # First column #R&gt; [1] &quot;Ashland&quot; &quot;Bayfield&quot; &quot;Douglas&quot; &quot;Iron&quot; &quot;Sawyer&quot; Note that choosing rows or more than one column will return a data frame as it will likely have data of different classes. class(counties[1,]) # one row is a data frame #R&gt; [1] &quot;data.frame&quot; class(counties[,c(1,2)]) # two columns is a data frame #R&gt; [1] &quot;data.frame&quot; However, choosing one column will return a vector of items all of the same class. class(counties[,1]) # one column is a vector #R&gt; [1] &quot;character&quot; As columns are named we can also use the name to access a specific column. counties[,&quot;pop&quot;] #R&gt; [1] 15512 15056 43164 5687 16746 This same column can be accessed by separating the data frame object name from the column name with a $. counties$pop #R&gt; [1] 15512 15056 43164 5687 16746 Again a column is simply a vector so you access single items in this vector in the usual way. counties$pop[3] #R&gt; [1] 43164 A $ is only used to separate a data frame name from the variable name within that data frame. 2.3.1 Tibbles Tibbles are a special form of data frame that was introduced as part of the tidyverse. Tibbles are created using tibble() in the same way that we used data.frame() previously. counties2 &lt;- tibble(name=c(&quot;Ashland&quot;,&quot;Bayfield&quot;,&quot;Douglas&quot;,&quot;Iron&quot;,&quot;Sawyer&quot;), pop=c(15512,15056,43164,5687,16746), party=c(&quot;Dem&quot;,&quot;Dem&quot;,&quot;Dem&quot;,&quot;Rep&quot;,&quot;Rep&quot;)) For most of our purposes a tibble will behave exactly as a data frame. For example, counties2 #R&gt; # A tibble: 5 x 3 #R&gt; name pop party #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep counties2$pop #R&gt; [1] 15512 15056 43164 5687 16746 There are, however, differences between tibbles and data frames as described in this introduction to tibbles. The primary difference that you will notice in this course is that when you examine the contents of a tibble with a larger number of rows, columns, or both. For example the code below converts a data frame from the FSA package into a tibble. tibex &lt;- as_tibble(FSA::WhitefishLC) However, when you try to display the data in this tibble you can see that only first 10 rows and as many columns as will fit on the width of your display are shown. In this case, 141 rows and one variable are not shown as seen in the note at the bottom. tibex #R&gt; # A tibble: 151 x 11 #R&gt; fishID tl scale1 scale2 scaleC finray1 finray2 finrayC otolith1 otolith2 #R&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #R&gt; 1 1 345 3 3 3 3 3 3 3 3 #R&gt; 2 2 334 4 3 4 3 3 3 3 3 #R&gt; 3 3 348 7 5 6 3 3 3 3 3 #R&gt; 4 4 300 4 3 4 3 2 3 3 3 #R&gt; 5 5 330 3 3 3 4 3 4 3 3 #R&gt; 6 6 316 4 4 4 2 3 3 6 5 #R&gt; 7 7 508 6 7 7 6 6 6 9 10 #R&gt; 8 8 475 4 5 5 9 9 9 11 12 #R&gt; 9 9 340 3 3 3 2 3 3 3 4 #R&gt; 10 10 173 1 1 1 2 1 1 1 1 #R&gt; # ... with 141 more rows, and 1 more variable: otolithC &lt;int&gt; We will encounter tibbles in subsequent modules as some tidyverse functions return tibbles by default. A tibble can be converted to a data frame with as.data.frame(). 2.4 Tidy Data Tidy Data was a term introduced here in 2011 to describe a strict data organization that leads to consistency and efficiencies in data analyses. Tidy data is described in more detail here. Data can be organized in different ways. For example, below is the simple data frame from Section 2.3. #R&gt; name pop party #R&gt; 1 Ashland 15512 Dem #R&gt; 2 Bayfield 15056 Dem #R&gt; 3 Douglas 43164 Dem #R&gt; 4 Iron 5687 Rep #R&gt; 5 Sawyer 16746 Rep However, these same data could be organized as below (among other possible organizations). #R&gt; county variable value #R&gt; 1 Ashland pop 15512 #R&gt; 2 Ashland party Dem #R&gt; 3 Bayfield pop 15056 #R&gt; 4 Bayfield party Dem #R&gt; 5 Douglas pop 43164 #R&gt; 6 Douglas party Dem #R&gt; 7 Iron pop 5687 #R&gt; 8 Iron party Rep #R&gt; 9 Sawyer pop 16746 #R&gt; 10 Sawyer party Rep This second data frame is not tidy and is much more difficult to use. Tidy data frames follow three simple rules: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. The original data frame above is tidy. A common challenge when entering data in a tidy format occurs when data is recorded on individuals in separate groups. For example, the following data are methyl mercury levels recorded in mussels from two locations labeled as impacted and reference. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 In this case, you must realize that one observation is a methyl mercury measurement on a mussel AND to which group the mussel belongs. Thus, each observation results in the recording of two variables. For example, the first mussel had a methyl mercury level of 0.011 AND it was at the impacted site. With this understanding these data are entered in a tidy format as follows. mussels &lt;- tibble(loc=c(&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;,&quot;impacted&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;, &quot;reference&quot;,&quot;reference&quot;,&quot;reference&quot;), merc=c(0.011,0.054,0.056,0.095,0.051,0.077, 0.031,0.040,0.029,0.066,0.018,0.042,0.044)) mussels #R&gt; # A tibble: 13 x 2 #R&gt; loc merc #R&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 impacted 0.011 #R&gt; 2 impacted 0.054 #R&gt; 3 impacted 0.056 #R&gt; 4 impacted 0.095 #R&gt; 5 impacted 0.051 #R&gt; 6 impacted 0.077 #R&gt; 7 reference 0.031 #R&gt; 8 reference 0.04 #R&gt; 9 reference 0.029 #R&gt; 10 reference 0.066 #R&gt; 11 reference 0.018 #R&gt; 12 reference 0.042 #R&gt; 13 reference 0.044 Tidy data will facilitate data wrangling in subsequent modules and data analysis and graphing in other courses. "],["external-data-files.html", "Module 3 External Data Files 3.1 Entering Data 3.2 Saving the External File 3.3 Reading the External File", " Module 3 External Data Files Most realistic data has more than a few individuals and is, thus, not easily entered using data.frame() or tibble() as shown in Section 2.3. Rather these data are often entered and stored in a spreadsheet or database that is external to R and, thus, needs to be read or loaded into R. This module describes how data should be entered into a spreadsheet and then how that data is read into R. 3.1 Entering Data Tidy data (see Section 2.4) is often read into a spreadsheet program such as Microsoft Excel or Google Sheets. The spreadsheet should be organized with variables in columns and individuals in rows, with the exception that the first row should contain variable names. The example spreadsheet below shows the length (cm), weight (kg), and capture location data for a small sample of Black Bears.   Variable names should NOT contain spaces. For example, dont use total length or length (cm). If you feel the need to have longer variable names, then separate the parts with a period (e.g., length.cm) or an underscore (e.g., length_cm). Variable names can NOT start with numbers or contain special characters such as ~, ! &amp;, @, etc. Furthermore, numerical measurements should NOT include units (e.g., dont use 7 cm). Finally, for categorical data, make sure that all categories are consistent (e.g., do not use both bayfield and Bayfield). When entering data make sure to follow the three rules of tidy data (see Section 2.4). For example, the following data are methyl mercury levels recorded in mussels captured from impacted and reference locations. impacted 0.011 0.054 0.056 0.095 0.051 0.077 reference 0.031 0.040 0.029 0.066 0.018 0.042 0.044 As described in Section 2.4, one observation (i.e., row) is a methyl mercury measurement on a mussel AND which group the mussel belongs. The rules for tidy data dictate two columns (one for each of the two variables recorded) and 13 rows (one for each obseration of a mussel). format as follows. Thus, these data would be entered into the spreadsheet as shown below.   3.2 Saving the External File The spreadsheet may be saved in the format of the spreadsheet program (e.g., as an Excel file) to be read into R. However, it is also common to save the file as a comma separated values (CSV) file to be read into R. The advantage of a CSV file is that these files are small and, because they do not require any special software (e.g., Excel) to read, they are very likely to always be able to be read into R. 3.2.1 Excel An Excel worksheet is saved as a CSV file by selecting the File..Save As menu item, which will produce the dialog box below. In this dialog box, change Save as type to CSV (Comma delimited),1, provide a file name (do not put any periods in the name), select a location to save the file (this should be the same location as your assignment template file), and press Save. Two warning dialog boxes may then appear  select OK for the first and YES for the second. You can now close the spreadsheet file.2 3.2.2 Google Sheets A Google Sheet can be made available as a CSV file with the following steps by selecting the File menu, Share submenu, and Publish to web submenu. In the ensuing dialog box, change Entire Document to name of the sheet you want to publish and Web Page to Comma-separated values (.csv) under the Link tab. Then press the Publish button and press OK when asked to confirm publishing. Finally, select and copy (CTRL-C or CMD-C) the entire link shown in the box above. This link will be used as described in the next section. 3.3 Reading the External File 3.3.1 CSV Files CSV files may be read with read.csv() from base R or read_csv() from tidyverse. For most of our applications there will be little functional difference between these two functions. However, read_csv() is faster than read.csv() and can be a little smarter about the way it imports certain columns.3 In addition, it is a bit more transparent about what it is doing. For those reasons, we will use read_csv() in this course. An object saved from read_csv() will be a tibble. The first argument to read_csv() is the filename. This file must exist in your working directory, include be a partial path relative to your working directory or a full path to the file, or be a valid URL. For example, the code below reads Bears.csv from the data folder in my working directory and stores the result in the bears object. Here, I used file.path() to combine the folder names in the partial path with the filename because file.path() creates at path that will be correct for your operating system.4 bears &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears.csv&quot;)) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The filename argument could also be the link to the published Google Sheet (from above). bears &lt;- read_csv(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vQaxD9tvwL29MydISlYw4bVXrw6-rvkEbT_2qFGxw7HuYX6M3h83aIYT4eZ-mrrEfJf8y5Q8p1Rkn4Z/pub?gid=522647677&amp;single=true&amp;output=csv&quot;) bears #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas The URL does not have to be from the published Google Sheet. For example, the following reads a CSV from this page that lists information about every player who has played in the National Basketball Association (NBA). players &lt;- read_csv(&quot;https://sports-statistics.com/database/basketball-data/nba/NBA-playerlist.csv&quot;) players #R&gt; # A tibble: 4,393 x 15 #R&gt; X1 DISPLAY_FIRST_LAST DISPLAY_LAST_COMMA_FIRST FROM_YEAR GAMES_PLAYED_FL~ #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 0 Alaa Abdelnaby Abdelnaby, Alaa 1990 Y #R&gt; 2 1 Zaid Abdul-Aziz Abdul-Aziz, Zaid 1968 Y #R&gt; 3 2 Kareem Abdul-Jabbar Abdul-Jabbar, Kareem 1969 Y #R&gt; 4 3 Mahmoud Abdul-Rauf Abdul-Rauf, Mahmoud 1990 Y #R&gt; 5 4 Tariq Abdul-Wahad Abdul-Wahad, Tariq 1997 Y #R&gt; 6 5 Shareef Abdur-Rahim Abdur-Rahim, Shareef 1996 Y #R&gt; 7 6 Tom Abernethy Abernethy, Tom 1976 Y #R&gt; 8 7 Forest Able Able, Forest 1956 Y #R&gt; 9 8 John Abramovic Abramovic, John 1946 Y #R&gt; 10 9 Alex Abrines Abrines, Alex 2016 Y #R&gt; # ... with 4,383 more rows, and 10 more variables: #R&gt; # OTHERLEAGUE_EXPERIENCE_CH &lt;chr&gt;, PERSON_ID &lt;dbl&gt;, PLAYERCODE &lt;chr&gt;, #R&gt; # ROSTERSTATUS &lt;dbl&gt;, TEAM_ABBREVIATION &lt;chr&gt;, TEAM_CITY &lt;chr&gt;, #R&gt; # TEAM_CODE &lt;chr&gt;, TEAM_ID &lt;dbl&gt;, TEAM_NAME &lt;chr&gt;, TO_YEAR &lt;dbl&gt;   The read_csv() function provides a variety of options that will help you correctly load CSV files that may be quirky in some respects. Use skip.lines= to skip, for example, the first two lines in a CSV file that do not contain data (perhaps they hold comments). tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_SkipLines.csv&quot;),skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Alternatively, use comment= to identify leading characters that identify lines in the data file that are comments and should not be read as data. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Comment.csv&quot;),comment=&quot;#&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Often data may be missing. By default, R treats NA in the data frame as missing data. If all missing data is coded with NA then read_csv() will handle this properly. For example, note the NAs in the second and eighth rows below. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing1.csv&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; However, some researcher may denote missing data with other codes. For example, the data file read below used - denote missing data. In cases like this, use na= to dictate which codes should be missing and converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing2.csv&quot;),na=&quot;-&quot;) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt; In other instances, the research may have sloppily used multiple codes for missing data. In these instances, set na= to a vector of all codes to be converted to NA in the data frame object. tmp &lt;- read_csv(file.path(&quot;data&quot;,&quot;Bears_Missing3.csv&quot;),na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.2 Excel Files Some researchers prefer to save data entered in Excel as an Excel workbook rather than a CSV file. The main argument here is that saving to a CSV often results in two files  an Excel workbook file and a CSV file. It is generally bad practice to have your data in two files as you may update the Excel file and forget to save it to the CSV file or you may update the CSV file and forget to also update the Excel file. Regardless of the reason, data can generally be read from an Excel file into R. The read_excel() function from the readxl package provides a coherent process for reading data from an Excel workbook. The first argument to read_excel() is the name of the Excel file, possibly with path information. By default read_excel() reads the first sheet in the Excel workbook. The example below reads the first sheet of the DataExamples.xlsx workbook in the data folder.5 tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Data on specific sheets can be read by including the sheet name in sheet=. Additionally, lines at the top of the sheet can be skipped with skip= as described for read_csv(). For example, the code below reads the data after the first two lines in the Bears_SkipLines worksheet in the same Excel workbook. tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_SkipLines&quot;,skip=2) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 Bayfield #R&gt; 2 120. 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 141 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 Douglas Missing data is handled exactly as described for read_csv(). tmp &lt;- readxl::read_excel(file.path(&quot;data&quot;,&quot;DataExamples.xlsx&quot;), sheet=&quot;Bears_Missing3&quot;,na=c(&quot;NA&quot;,&quot;NAN&quot;,&quot;-&quot;)) tmp #R&gt; # A tibble: 8 x 3 #R&gt; length.cm weight.kg loc #R&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 139 110 &lt;NA&gt; #R&gt; 2 NA 60 Bayfield #R&gt; 3 149 85 Bayfield #R&gt; 4 141 100 Ashland #R&gt; 5 NA 95 Ashland #R&gt; 6 150 85 Douglas #R&gt; 7 130. 105 Douglas #R&gt; 8 150 110 &lt;NA&gt;   In general, read_excel() works best if the data are arranged rectangularly starting in cell A1. However, read_excel() can handle different organizations of data in the worksheet as described here. Researchers may also use multiple header rows in their Excel worksheet; e.g., variables names in the first row, variable units in the second row. This provides a strategy for reading data arranged in such a way. The examples above will serve you well for most files read in this class, with the possible exception of files that contain variables with dates. Handling dates is discussed XXXXXX. 3.3.3 Google Sheets It is also possible to read a file directly from Google Sheets using functions in the googlesheets4 package as described here. Using this package to read directly from Google Sheets requires you to authorize R to access your Google Sheets. 3.3.4 Other Formats Data may be stored in other, less common formats. A rew examples of functions to read these other formats are listed below. read_csv2() (from tidyverse) for fields separated by semi-colons (rather than commas) as is common in Europe. read_tsv() (from tidyverse) for fields separated by tabs (rather than commas). read_fwf() (from tidyverse) for fields that are a fixed width. read_sav() (from haven) for .sav files from SPSS. read_sas() (from haven) for .sas7bdat and .sas7bcat files from SAS. read_dta() (from haven) for .dta files from Stata. There are several choices for CSV files here; do NOT choose the one with UTF-8 in the name. You may be asked to save changes  you should say No. How read_csv() identifies the class of data in a column is described here Windows and Mac OS handle paths differently; this function avoids that complication. I use the readxl::read_excel() construct here rather than loading the readxl package and then simply using read_excel() because this is the only function that I will use from readxl. Thus, I am not loading unneeded functions into my work environment. "],["relational-data.html", "Module 4 Relational Data 4.1 Join Concepts 4.2 Joins in R 4.3 Examples With Context", " Module 4 Relational Data Some situations will have multiple data frames with related data. A particular analysis may require combining these data frames into a single data frame. If the data in the separate data frames are connected by a key variable then the data are said to be relational  i.e., they relate to each other through a common variable (or variables). As an example a college may have the following four data frames with respect to its students. Personal information (hometown, age, etc.) Financial aid information (family income, Pell Grant aid amount, etc.) Academic information (standing, major, gpa, etc.) Current course information (i.e., which courses a students is registered for) Each of these data frames would also contain a student ID variable so that a students personal information can be connect with the students financial aid, academic, or course information. This student ID variable is the key variable for these relational data frames. Data from related data frames can be joined in a variety of ways. This module will explain several types of joins and how to accomplish those joins in R. 4.1 Join Concepts To illustrate the various joins, suppose that a simple data frame x exists that has an id key variable and a val1 measurement variable.6 id val1 101 x1 102 x2 102 x3 103 x4 Further suppose that a second data frame y has the same id key variable and different val2 and val3 measurement variables.7 id val2 val3 101 y1 z1 102 y2 z2 104 y3 z3 104 y4 z4 It is instructive when learning about joins to visualize all combinations of observations in the two data frames.8 As some key variable values may be missing in the data frames we also consider combinations with a missing key variable value (and the measurement variables set to NA), All combinations of the rows in x and y with the missing key values are shown on the left for each join type in the subsections below. 4.1.1 Inner Join An inner join is the simplest join. It returns values from both data frames where the key variable(s) match in both data frames. In our simple data frames an inner join returns the rows from all combinations of rows (see left below) where the id variables (i.e., colors) from x and y match (see center below). The final result is these rows with the duplicated id key variable removed (see right below). All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for inner join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final inner join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 Inner Join: Rows from both data frames where the key variable columns match. 4.1.2 Left Join A left join returns the same rows as an inner join (i.e., all rows where the key variables match) AND all rows from the first data frame that dont have a key variable match in the second data frame. The values for the variables in the second data frame for key values in the first data frame without a match are replaced with NAs. So, a left join will include rows for all key variables from the first data frame, but only rows from the second data frame that had a key variable match with the first data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for left join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final left join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA Left Join: All rows from the first data frame with variables from the second data frame where the key variable columns match (NA otherwise). 4.1.3 Right Join A right join works just like a left join except that the result will include all rows from the second data frame that dont have a key variable match in the first data frame. A right join can also be accomplished with a left join by reversing the order of the two data frames. Right Join: All rows from the second data frame with variables from the first data frame where the key variable columns match (NA otherwise). 4.1.4 Full Join A full join returns the same rows as an inner join (i.e., all rows where the key variable match) AND all rows from each data frame that dont have a key variable match in the other data frame. So a full join will include rows for all key variables from both data frames. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for full join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final full join result id val1 val2 val3 101 x1 y1 z1 102 x2 y2 z2 102 x3 y2 z2 103 x4 NA NA 104 NA y3 z3 104 NA y4 z4 Full Join: All rows from both data frame with variables from the other data frame where the key variable columns match (NA otherwise). 4.1.5 Semi Join In a semi join only values from the first data frame that have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows that had a key variable match in the second data frame. This is the same result as an inner join but without including the variables from the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for semi join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final semi join result id val1 101 x1 102 x2 102 x3 Semi Join: All variables from the first data frame for rows where the key variable column has a match in the second data frame. 4.1.6 Anti Join In an anti join only values from the first data frame that DO NOT have a key variable match in the second data frame are retained. Thus, the final result will only have variables from the first data frame for rows without a key variable match in the second data frame. All combinations from x and y id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Retained for anti join id.x val1 id.y val2 val3 101 x1 101 y1 z1 101 x1 102 y2 z2 101 x1 104 y3 z3 101 x1 104 y4 z4 101 x1 NA NA 102 x2 101 y1 z1 102 x2 102 y2 z2 102 x2 104 y3 z3 102 x2 104 y4 z4 102 x2 NA NA 102 x3 101 y1 z1 102 x3 102 y2 z2 102 x3 104 y3 z3 102 x3 104 y4 z4 102 x3 NA NA 103 x4 101 y1 z1 103 x4 102 y2 z2 103 x4 104 y3 z3 103 x4 104 y4 z4 103 x4 NA NA NA 101 y1 z1 NA 102 y2 z2 NA 104 y3 z3 NA 104 y4 z4 Final anti join result id val1 103 x4 Anti Join: All variables from the first data frame for rows where the key variable column does NOT have a match in the second data frame.   4.2 Joins in R Performing the joins described in the previous section is straightforward with dplyr (part of the tidyverse) using, conveniently enough, inner_join(), left_join(), right_join(), full_join(), semi_join(), and anti_join(). The first two arguments to each of these functions are the two data frames to join. In addition, the name of the key variable should be given, in quotes, to by=.9 The two data frames used in the previous section are created below as objects in R. x &lt;- data.frame(id=c(101,102,102,103),val1=paste0(&quot;x&quot;,1:4)) x #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 #R&gt; 4 103 x4 y &lt;- data.frame(id=c(101,102,104,104),val2=paste0(&quot;y&quot;,1:4),val3=paste0(&quot;z&quot;,1:4)) y #R&gt; id val2 val3 #R&gt; 1 101 y1 z1 #R&gt; 2 102 y2 z2 #R&gt; 3 104 y3 z3 #R&gt; 4 104 y4 z4   The six joins discussed in the previous section are completed below. You should compare the results here to the visual results above. ij &lt;- inner_join(x,y,by=&quot;id&quot;) ij #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 lj &lt;- left_join(x,y,by=&quot;id&quot;) lj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; rj &lt;- right_join(x,y,by=&quot;id&quot;) rj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 104 &lt;NA&gt; y3 z3 #R&gt; 5 104 &lt;NA&gt; y4 z4 rj2 &lt;- left_join(y,x,by=&quot;id&quot;) # right_join as left_join with x &amp; y reversed rj2 #R&gt; id val2 val3 val1 #R&gt; 1 101 y1 z1 x1 #R&gt; 2 102 y2 z2 x2 #R&gt; 3 102 y2 z2 x3 #R&gt; 4 104 y3 z3 &lt;NA&gt; #R&gt; 5 104 y4 z4 &lt;NA&gt; fj &lt;- full_join(x,y,by=&quot;id&quot;) fj #R&gt; id val1 val2 val3 #R&gt; 1 101 x1 y1 z1 #R&gt; 2 102 x2 y2 z2 #R&gt; 3 102 x3 y2 z2 #R&gt; 4 103 x4 &lt;NA&gt; &lt;NA&gt; #R&gt; 5 104 &lt;NA&gt; y3 z3 #R&gt; 6 104 &lt;NA&gt; y4 z4 sj &lt;- semi_join(x,y,by=&quot;id&quot;) sj #R&gt; id val1 #R&gt; 1 101 x1 #R&gt; 2 102 x2 #R&gt; 3 102 x3 aj &lt;- anti_join(x,y,by=&quot;id&quot;) aj #R&gt; id val1 #R&gt; 1 103 x4   4.3 Examples With Context The following examples demonstrate different types of joins within fictitious, but realistic, contexts. Please examine each data frame and the joined results carefully to help further understand what each type of join does. 4.3.1 Student Data (One-to-One) In large institutions or in complicated data environments, data about specific individuals may be housed in a variety of departments each of which maintains its own database. Preferably these data sources can be related via a primary key variable, such as a unique student ID number. As an example, suppose that a colleges admissions office maintains a database of personal information about every student at the college. For example it might look like that below for a fictitious five students. personal &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), first_nm=c(&quot;Rolando&quot;,&quot;Catherine&quot;,&quot;James&quot;,&quot;Rachel&quot;,&quot;Esteban&quot;), last_nm=c(&quot;Blackman&quot;,&quot;Johnson&quot;,&quot;Carmichael&quot;,&quot;Brown&quot;,&quot;Perez&quot;), hometown=c(&quot;Windsor&quot;,&quot;Eden Prairie&quot;,&quot;Marion&quot;,&quot;Milwaukee&quot;,&quot;El Paso&quot;), homestate=c(&quot;MI&quot;,&quot;MN&quot;,&quot;IA&quot;,&quot;WI&quot;,&quot;TX&quot;)) personal #R&gt; studentID first_nm last_nm hometown homestate #R&gt; 1 34535 Rolando Blackman Windsor MI #R&gt; 2 45423 Catherine Johnson Eden Prairie MN #R&gt; 3 73424 James Carmichael Marion IA #R&gt; 4 89874 Rachel Brown Milwaukee WI #R&gt; 5 98222 Esteban Perez El Paso TX In addition the financial aid office may have a database of financial aid information. finaid &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), income_cat=c(4,5,3,2,3), pell_elig=c(TRUE,FALSE,TRUE,TRUE,TRUE), work_study=c(TRUE,FALSE,FALSE,FALSE,TRUE)) finaid #R&gt; studentID income_cat pell_elig work_study #R&gt; 1 34535 4 TRUE TRUE #R&gt; 2 45423 5 FALSE FALSE #R&gt; 3 73424 3 TRUE FALSE #R&gt; 4 89874 2 TRUE FALSE #R&gt; 5 98222 3 TRUE TRUE Furthermore the registrars office has a database of academic information. academics &lt;- data.frame(studentID=c(34535,45423,73424,89874,98222), standing=c(&quot;FY&quot;,&quot;FY&quot;,&quot;SO&quot;,&quot;SR&quot;,&quot;JR&quot;), major=c(&quot;undecided&quot;,&quot;NRS&quot;,&quot;Biology&quot;,&quot;SCD&quot;,&quot;SCD&quot;), cum_gpa=c(0,0,3.12,3.67,2.89)) academics #R&gt; studentID standing major cum_gpa #R&gt; 1 34535 FY undecided 0.00 #R&gt; 2 45423 FY NRS 0.00 #R&gt; 3 73424 SO Biology 3.12 #R&gt; 4 89874 SR SCD 3.67 #R&gt; 5 98222 JR SCD 2.89 Note how each of these databases has the studentID variable that will serve as the key variable to connect each students information across each of the databases. These databases form what is called a one-to-one relationship because as each observation record in each database can be connected to one and only one observation record in the other databases. In this example, each database would ideally have an entry for every student. These data frames can generally be joined with inner, left, or right joins depending on the purpose. For example, an institutional researcher may want to examine whether student gpa differed between students that were eligible for a Pell Grant or not. In this case, the researcher would join the finaid and academics data frames so that the pell_elig and cum_gpa variables would be in one data frame. tmp &lt;- inner_join(finaid,academics,by=&quot;studentID&quot;) tmp #R&gt; studentID income_cat pell_elig work_study standing major cum_gpa #R&gt; 1 34535 4 TRUE TRUE FY undecided 0.00 #R&gt; 2 45423 5 FALSE FALSE FY NRS 0.00 #R&gt; 3 73424 3 TRUE FALSE SO Biology 3.12 #R&gt; 4 89874 2 TRUE FALSE SR SCD 3.67 #R&gt; 5 98222 3 TRUE TRUE JR SCD 2.89 An inner join was used here because the researcher only wants to include students that are in both databases (i.e., would likely have an entry for both pell_elig and cum_gpa). Note, however, that a left join or a right join would accomplish the same task as long as both databases had entries for every student (i.e., the databases have the same set of students).   Further suppose that academic advisors would like to have the students names attached to these records so that they could reach out to students who could use some help academically. tmp &lt;- inner_join(personal,tmp,by=&quot;studentID&quot;) tmp #R&gt; studentID first_nm last_nm hometown homestate income_cat pell_elig #R&gt; 1 34535 Rolando Blackman Windsor MI 4 TRUE #R&gt; 2 45423 Catherine Johnson Eden Prairie MN 5 FALSE #R&gt; 3 73424 James Carmichael Marion IA 3 TRUE #R&gt; 4 89874 Rachel Brown Milwaukee WI 2 TRUE #R&gt; 5 98222 Esteban Perez El Paso TX 3 TRUE #R&gt; work_study standing major cum_gpa #R&gt; 1 TRUE FY undecided 0.00 #R&gt; 2 FALSE FY NRS 0.00 #R&gt; 3 FALSE SO Biology 3.12 #R&gt; 4 FALSE SR SCD 3.67 #R&gt; 5 TRUE JR SCD 2.89   Continuing with this example, suppose that the registrars office also maintains a database that contains each students current class schedule. schedules &lt;- tibble(studentID=c(34535,34535,34535,34535, 45423,45423,45423,45423,45423, 73424,73424,73424,73424, 89874,89874,89874, 98222,98222,98222,98222), course=c(&quot;MTH107&quot;,&quot;BIO115&quot;,&quot;CHM110&quot;,&quot;IDS101&quot;, &quot;SCD110&quot;,&quot;PSY110&quot;,&quot;MTH140&quot;,&quot;OED212&quot;,&quot;IDS101&quot;, &quot;BIO234&quot;,&quot;CHM220&quot;,&quot;BIO370&quot;,&quot;SCD110&quot;, &quot;SCD440&quot;,&quot;PSY370&quot;,&quot;IDS490&quot;, &quot;SCD440&quot;,&quot;SCD330&quot;,&quot;SOC480&quot;,&quot;ART220&quot;)) schedules #R&gt; # A tibble: 20 x 2 #R&gt; studentID course #R&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 #R&gt; 2 34535 BIO115 #R&gt; 3 34535 CHM110 #R&gt; 4 34535 IDS101 #R&gt; 5 45423 SCD110 #R&gt; 6 45423 PSY110 #R&gt; 7 45423 MTH140 #R&gt; 8 45423 OED212 #R&gt; 9 45423 IDS101 #R&gt; 10 73424 BIO234 #R&gt; 11 73424 CHM220 #R&gt; 12 73424 BIO370 #R&gt; 13 73424 SCD110 #R&gt; 14 89874 SCD440 #R&gt; 15 89874 PSY370 #R&gt; 16 89874 IDS490 #R&gt; 17 98222 SCD440 #R&gt; 18 98222 SCD330 #R&gt; 19 98222 SOC480 #R&gt; 20 98222 ART220 The registrars office also maintains a database of information about every course taught at the college. A partial example of such a database is shown below.10 courses &lt;- tibble(course=c(&quot;ART220&quot;,&quot;ART330&quot;,&quot;BIO115&quot;,&quot;BIO234&quot;,&quot;BIO370&quot;,&quot;BIO490&quot;, &quot;CHM110&quot;,&quot;CHM220&quot;,&quot;CHM360&quot;,&quot;IDS101&quot;,&quot;IDS490&quot;,&quot;MTH107&quot;, &quot;MTH140&quot;,&quot;MTH230&quot;,&quot;OED212&quot;,&quot;OED330&quot;,&quot;OED360&quot;,&quot;PSY110&quot;, &quot;PSY370&quot;,&quot;SCD110&quot;,&quot;SCD330&quot;,&quot;SCD440&quot;,&quot;SOC111&quot;,&quot;SOC480&quot;), credits=c(3,3,4,4,4,4,4,4,4,3,4,4,4,4,3,3,3,4,4,3,3,4,4,4), instructor=c(&quot;Duffy&quot;,&quot;Terry&quot;,&quot;Johnson&quot;,&quot;Goyke&quot;,&quot;Anich&quot;,&quot;Anich&quot;, &quot;Carlson&quot;,&quot;Robertson&quot;,&quot;Carlson&quot;,&quot;Goyke&quot;,&quot;Hannickel&quot;,&quot;Ogle&quot;, &quot;Jensen&quot;,&quot;Jensen&quot;,&quot;Andre&quot;,&quot;Andre&quot;,&quot;Coulson&quot;,&quot;Sneyd&quot;, &quot;Sneyd&quot;,&quot;Tochterman&quot;,&quot;Tochterman&quot;,&quot;Foster&quot;, &quot;Schanning&quot;,&quot;Schanning&quot;)) courses #R&gt; # A tibble: 24 x 3 #R&gt; course credits instructor #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 ART220 3 Duffy #R&gt; 2 ART330 3 Terry #R&gt; 3 BIO115 4 Johnson #R&gt; 4 BIO234 4 Goyke #R&gt; 5 BIO370 4 Anich #R&gt; 6 BIO490 4 Anich #R&gt; 7 CHM110 4 Carlson #R&gt; 8 CHM220 4 Robertson #R&gt; 9 CHM360 4 Carlson #R&gt; 10 IDS101 3 Goyke #R&gt; # ... with 14 more rows These two data frames are related via the common course variable. This type of database organization is particularly useful because the information about any one course only needs to be entered once in courses even though the actual course may appear many times in schedules. This helps save time and reduces data entry errors. It is easy to add the specific course information (credits and instructor) from courses to the students course information in schedules with a left_join(). schedules2 &lt;- left_join(schedules,courses,by=&quot;course&quot;) schedules2 #R&gt; # A tibble: 20 x 4 #R&gt; studentID course credits instructor #R&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #R&gt; 1 34535 MTH107 4 Ogle #R&gt; 2 34535 BIO115 4 Johnson #R&gt; 3 34535 CHM110 4 Carlson #R&gt; 4 34535 IDS101 3 Goyke #R&gt; 5 45423 SCD110 3 Tochterman #R&gt; 6 45423 PSY110 4 Sneyd #R&gt; 7 45423 MTH140 4 Jensen #R&gt; 8 45423 OED212 3 Andre #R&gt; 9 45423 IDS101 3 Goyke #R&gt; 10 73424 BIO234 4 Goyke #R&gt; 11 73424 CHM220 4 Robertson #R&gt; 12 73424 BIO370 4 Anich #R&gt; 13 73424 SCD110 3 Tochterman #R&gt; 14 89874 SCD440 4 Foster #R&gt; 15 89874 PSY370 4 Sneyd #R&gt; 16 89874 IDS490 4 Hannickel #R&gt; 17 98222 SCD440 4 Foster #R&gt; 18 98222 SCD330 3 Tochterman #R&gt; 19 98222 SOC480 4 Schanning #R&gt; 20 98222 ART220 3 Duffy Note here that if we consider schedules as the primary data frame of interest then this relationship is still a one-to-one relationship because each course in schedules can be connected to only one course record in courses.   The students personal information can also be added to these results with a left_join() but now using the studentID key variable. schedules2 &lt;- left_join(personal,schedules2,by=&quot;studentID&quot;) schedules2 #R&gt; studentID first_nm last_nm hometown homestate course credits #R&gt; 1 34535 Rolando Blackman Windsor MI MTH107 4 #R&gt; 2 34535 Rolando Blackman Windsor MI BIO115 4 #R&gt; 3 34535 Rolando Blackman Windsor MI CHM110 4 #R&gt; 4 34535 Rolando Blackman Windsor MI IDS101 3 #R&gt; 5 45423 Catherine Johnson Eden Prairie MN SCD110 3 #R&gt; 6 45423 Catherine Johnson Eden Prairie MN PSY110 4 #R&gt; 7 45423 Catherine Johnson Eden Prairie MN MTH140 4 #R&gt; 8 45423 Catherine Johnson Eden Prairie MN OED212 3 #R&gt; 9 45423 Catherine Johnson Eden Prairie MN IDS101 3 #R&gt; 10 73424 James Carmichael Marion IA BIO234 4 #R&gt; 11 73424 James Carmichael Marion IA CHM220 4 #R&gt; 12 73424 James Carmichael Marion IA BIO370 4 #R&gt; 13 73424 James Carmichael Marion IA SCD110 3 #R&gt; 14 89874 Rachel Brown Milwaukee WI SCD440 4 #R&gt; 15 89874 Rachel Brown Milwaukee WI PSY370 4 #R&gt; 16 89874 Rachel Brown Milwaukee WI IDS490 4 #R&gt; 17 98222 Esteban Perez El Paso TX SCD440 4 #R&gt; 18 98222 Esteban Perez El Paso TX SCD330 3 #R&gt; 19 98222 Esteban Perez El Paso TX SOC480 4 #R&gt; 20 98222 Esteban Perez El Paso TX ART220 3 #R&gt; instructor #R&gt; 1 Ogle #R&gt; 2 Johnson #R&gt; 3 Carlson #R&gt; 4 Goyke #R&gt; 5 Tochterman #R&gt; 6 Sneyd #R&gt; 7 Jensen #R&gt; 8 Andre #R&gt; 9 Goyke #R&gt; 10 Goyke #R&gt; 11 Robertson #R&gt; 12 Anich #R&gt; 13 Tochterman #R&gt; 14 Foster #R&gt; 15 Sneyd #R&gt; 16 Hannickel #R&gt; 17 Foster #R&gt; 18 Tochterman #R&gt; 19 Schanning #R&gt; 20 Duffy These data frames represents a one-to-many relationship because studentID in personal is connected to many studentID records in schedules2 (one for each course the student is enrolled in).   4.3.2 Resource Sampling Data (One-to-Many Relationship) In sampling of natural resources it is common to have one database for information about the unit of sampling and another database specific to items within that sampling unit. For example, in fisheries we may have one database to record information about a particular net (e.g., where it is located, the date it was set) and a second database that records the species of fish caught and number of the species caught. You may be tempted to do this all in one database with a separate field for each fish species but this is inefficient as you may not know which species you may catch. Thus, every time you catch a new species you would need to add a new field or column to your database. In addition, this would be highly inefficient if you were to record information about individual fish (e.g., length and weight) as the amount of this information may vary from net to net. In this simple example, information about five specific settings of a net is stored in nets, which has a unique identifier for each net setting called net_num. nets &lt;- data.frame(net_num=1:5, lake=c(&quot;Eagle&quot;,&quot;Hart&quot;,&quot;Hart&quot;,&quot;Eagle&quot;,&quot;Millicent&quot;), date=c(&quot;3-Jul-21&quot;,&quot;3-Jul-21&quot;,&quot;5-Jul-21&quot;,&quot;6-Jul-21&quot;,&quot;6-Jul-21&quot;)) nets #R&gt; net_num lake date #R&gt; 1 1 Eagle 3-Jul-21 #R&gt; 2 2 Hart 3-Jul-21 #R&gt; 3 3 Hart 5-Jul-21 #R&gt; 4 4 Eagle 6-Jul-21 #R&gt; 5 5 Millicent 6-Jul-21 In a separate data frame the researchers recorded the species and number of each species caught in each net. Here there is a separate row for each species and its number caught with each row indexed to the specific net with the net_num key variable. catch &lt;- data.frame(net_num=c(1,1,2,2,2,4,4,5), species=c(&quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;,&quot;Bluntnose Minnow&quot;, &quot;Bluegill&quot;,&quot;Largemouth Bass&quot;, &quot;Largemouth Bass&quot;), number=c(7,3,19,2,56,3,6,3)) catch #R&gt; net_num species number #R&gt; 1 1 Bluegill 7 #R&gt; 2 1 Largemouth Bass 3 #R&gt; 3 2 Bluegill 19 #R&gt; 4 2 Largemouth Bass 2 #R&gt; 5 2 Bluntnose Minnow 56 #R&gt; 6 4 Bluegill 3 #R&gt; 7 4 Largemouth Bass 6 #R&gt; 8 5 Largemouth Bass 3 These data frames illustrate a one-to-many relationship as each record in nets may be connected to multiple records in catch. The catch data will be joined to the net data using a left_join() because it is important to keep track of nets that also did not catch fish. An inner_join() would only return nets where some fish were caught. fishcatch &lt;- left_join(nets,catch,by=&quot;net_num&quot;) fishcatch #R&gt; net_num lake date species number #R&gt; 1 1 Eagle 3-Jul-21 Bluegill 7 #R&gt; 2 1 Eagle 3-Jul-21 Largemouth Bass 3 #R&gt; 3 2 Hart 3-Jul-21 Bluegill 19 #R&gt; 4 2 Hart 3-Jul-21 Largemouth Bass 2 #R&gt; 5 2 Hart 3-Jul-21 Bluntnose Minnow 56 #R&gt; 6 3 Hart 5-Jul-21 &lt;NA&gt; NA #R&gt; 7 4 Eagle 6-Jul-21 Bluegill 3 #R&gt; 8 4 Eagle 6-Jul-21 Largemouth Bass 6 #R&gt; 9 5 Millicent 6-Jul-21 Largemouth Bass 3 The visualizations in this section are modified from https://twitter.com/hadleywickham/status/684407629259526148/photo/1. In this treatment, the unique id values are also uniquely color coded to help track individual observations in the descriptions below. Finding all combinations, however, is not needed to actually join two data frames. If by= is not explicitly set by the user then the two data frames will be joined using the variable(s) that the two data frames have in common for by=. A message will be displayed about which variable(s) was used; check this message carefully to make sure you are joining by the variables that you want to join by. I switched to using tibble() in the last two data frams only so that they may potentially print in a more concise manner. "],["pivoting.html", "Module 5 Pivoting 5.1 Data Formats 5.2 Pivoting Concepts 5.3 Pivoting in R 5.4 Examples with Context 5.5 Abundance of Mayflies", " Module 5 Pivoting Three rules of tidy data were introduced in Section 2.4. Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. There are a wide variety of ways to enter data. Some data will not be tidy because, for instance, it may be easier to enter data in a non-tidy format. For example, the data shown below is the number of positive confirmed COVID cases in Ashland, Bayfield, and Douglas counties in 2021 (through June).   County Jan_2021 Feb_2021 Mar_2021 Apr_2021 May_2021 Jun_2021 Ashland 139 27 31 41 45 3 Bayfield 100 33 28 54 36 15 Douglas 470 89 119 227 148 32   Data for future months can be easily entered by simply appending a new month on the right. These data are also easy to examine in this table, but in this format they are difficult to graph and can be difficult to summarize. Thus, these data need to be converted to a different format for some simple analyses.11 The objective of this module is to describe and demonstrate concepts and methods for converting data betwen different formats.   5.1 Data Formats Consider a situation with one measurement variable, x, recorded on four individuals at two times. These eight measurements could be entered in either the W or L data frames shown below.   W data.frame id x1 x2 A 1 5 B 2 6 C 3 7 D 4 8 L data.frame id time x A 1 1 A 2 5 B 1 2 B 2 6 C 1 3 C 2 7 D 1 4 D 2 8   In this case, a measurement of x on an individual at a single point in time is an observation; thus, each row should correspond to one measurement (value of x) on one individual. The W data frame is not tidy because multiple observations of x appear in each row of the data frame (i.e., the single measurement variable, x, is dispersed across two columns). The L data frame is tidy because each row corresponds to one observation (i.e., a unique combination of id and time) and the single measurement variable, x, now appears in only one column. Consider a similar example where two measurements (the variables x and y) were made (at the same time) on four individuals. These data may be entered as in V and Z below.   V data.frame id x y A 1 5 B 2 6 C 3 7 D 4 8 Z data.frame id variable value A x 1 A y 5 B x 2 B y 6 C x 3 C y 7 D x 4 D y 8   In this case V is tidy because each row corresponds to one observation (defined only by id) and each measurement variable (x and y) is in its own column. On the other hand Z is not tidy because observations are split into two rows and values of the two different measurement variables are lumped into the same column.   As you can see it can be difficult to identify the format that you want for your data. You cannot tell simply by the shape of the data  there will be times when you need the data to be longer (as in the first example above) and other times when you need the data to be wider (as in the second example above). As a general rule you should strive for your data to be tidy. For this start by identifying an observation is, which variables define the observations, and what the measurement variables are. Then determine if each row corresponds to one observation and if each measurement variable is in one column by itself. If the data do not meet these requirements then you likely need to convert it to a different format as described in the next sections.   5.2 Pivoting Concepts Each set of data described in the previous section could be entered in two formats. These formats are loosely called wider and longer based on their shapes relative to each other. converting between wider and longer format data is called A pivot. 5.2.1 Pivot Longer Pivot Longer is the conversion from a wider to a longer format. Pivotig to a longer format is usually needed if multiple observations of the same variable are recorded on individuals but are stored in separate columns of the data frame. This was the case with W above and also with the COVID data in the module introduction. To pivot from a wider to a longer format you must identify the variables in the wider format frame that contain the multiple measurements of the same variable. This was x1 and x2 in W. All other variables in the data frame are considered to represent a unique individual. In this case only the id variable is needed for this purpose. In addition, you must define names for variables in what will be the new longer format. The first name is for the variable that will identify the multiple measurements on the same individual. In this example the multiple measurements were taken at different times, so it seems logical to call the new variable time. The second name is for the variable that will hold the values of the measurement variable. Here the use of x1 and x2 in the original wider data frame suggest that this variable should be called x. The process of pivoting the wider W to a longer data frame is illustrated below.   5.2.2 Pivot Wider Pivot Wider is the process of converting from a longer to a wider data frame. You will typically pivot to a wider format if multiple measurement variables are recorded in one variable. This was the case with the Z data frame above. To Pivot Wider you must identify the variable in the longer data frame that contains what will be names of variables in the wider data frame. In this case, we want the data frame created from Z to have x and y has names of variables; thus, the name of this variable in Z is variable. In addition, you must identify the variable that has the values of the measurement variables that will separated into columns in the new data frame. In Z this variale is value. With these two definitions the process of pivoting the longer Z to a wider data frame is illustrated below.     5.3 Pivoting in R Pivoting W to a longer format and Z to a wider format in R are demonstrated in this section. The two data frames are created in R below. W &lt;- data.frame(id=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),x1=1:4,x2=5:8) W #R&gt; id x1 x2 #R&gt; 1 A 1 5 #R&gt; 2 B 2 6 #R&gt; 3 C 3 7 #R&gt; 4 D 4 8 Z &lt;- data.frame(id=rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;),each=2), variable=rep(c(&quot;x&quot;,&quot;y&quot;),times=4), value=c(1,5,2,6,3,7,4,8)) Z #R&gt; id variable value #R&gt; 1 A x 1 #R&gt; 2 A y 5 #R&gt; 3 B x 2 #R&gt; 4 B y 6 #R&gt; 5 C x 3 #R&gt; 6 C y 7 #R&gt; 7 D x 4 #R&gt; 8 D y 8 5.3.1 Pivot Longer Pivoting to a longer data frame is accomplished with pivot_longer(). The first argument is the name of the wider data frame. The following three arguments are also typically used. The variables in the wider data frame that represent multiple measurements of the same variable must be given in cols=. Note that these variables do NOT need to be in quotes because they exist in the wider data frame. There are multiple ways to do this in most situations; here are several for this situation.12 cols=x1:x2 will select all variables contiguous from between x1 to x2. cols=c(x1,x2) will select only variables x1 and x2. cols=starts_with(\"x\") will select all variables with names that begin with x. cols=-id will select all variables not named id. The name for the variable in the new longer data frame that will hold the index that represents the multiple measurements on the same individual is given in names_to=. The name for the variable that will hold the values of the measurement variable in the new longer data frame is given in values_to. Note that the variable names in names_to= and values_to= must be in quotes because they do not appear in an (as of yet) existing data frame. Given the definitions of these items in the previous section, the following code can be used to pivot W to a longer format. L &lt;- pivot_longer(W,cols=x1:x2,names_to=&quot;time&quot;,values_to=&quot;value&quot;) L #R&gt; # A tibble: 8 x 3 #R&gt; id time value #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A x1 1 #R&gt; 2 A x2 5 #R&gt; 3 B x1 2 #R&gt; 4 B x2 6 #R&gt; 5 C x1 3 #R&gt; 6 C x2 7 #R&gt; 7 D x1 4 #R&gt; 8 D x2 8 Note, however, that the time variable L contains x1 and x2 rather than 1 and 2. By default pivot_longer() uses the names of the variables you supplied in cols= in this variable. If these variables have a common pattern  as in they all start with x and end with the number that we want  then the portion of the pattern to remove can be given in names_prefix=.13 L &lt;- pivot_longer(W,cols=x1:x2,names_to=&quot;time&quot;,names_prefix=&quot;x&quot;,values_to=&quot;x&quot;) L #R&gt; # A tibble: 8 x 3 #R&gt; id time x #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A 1 1 #R&gt; 2 A 2 5 #R&gt; 3 B 1 2 #R&gt; 4 B 2 6 #R&gt; 5 C 1 3 #R&gt; 6 C 2 7 #R&gt; 7 D 1 4 #R&gt; 8 D 2 8   A reminder that all variables not given in cols= will be considered as identifying with the individuals in the data frame. Suppose for example that W had more columns that looked like this (data frame called W2 here). #R&gt; id fname lname years x1 x2 #R&gt; 1 A Derek Ogle 25 1 5 #R&gt; 2 B Young Kim 32 2 6 #R&gt; 3 C Andrew Jensen 6 3 7 #R&gt; 4 D Jodi Supanich 7 4 8 The same pivot_longer() with W2 will repeat the id, fname, lname, and years values. L2 &lt;- pivot_longer(W2,cols=x1:x2,names_to=&quot;time&quot;,names_prefix=&quot;x&quot;,values_to=&quot;value&quot;) L2 #R&gt; # A tibble: 8 x 6 #R&gt; id fname lname years time value #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; #R&gt; 1 A Derek Ogle 25 1 1 #R&gt; 2 A Derek Ogle 25 2 5 #R&gt; 3 B Young Kim 32 1 2 #R&gt; 4 B Young Kim 32 2 6 #R&gt; 5 C Andrew Jensen 6 1 3 #R&gt; 6 C Andrew Jensen 6 2 7 #R&gt; 7 D Jodi Supanich 7 1 4 #R&gt; 8 D Jodi Supanich 7 2 8   5.3.2 Pivot Wider Pivoting to a wider data frame is accomplished with pivot_wider(). The first argument is the name of the longer data frame. The following two arguments are all typically used. The name of the variable in the longer data frame that contains what will be names of variables in the wider data frame is given in names_from=. The name of the variable in the longer data frame that has the values of the measurement variable that will be separated into columns in the new data frame is given in values_from=. As both of these variables exist in the longer data frame they do NOT need to be in quotes. Given the definitions from the previous section Z is pivoted to a wider format with the following code. V &lt;- pivot_wider(Z,names_from=variable,values_from=value) V #R&gt; # A tibble: 4 x 3 #R&gt; id x y #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 A 1 5 #R&gt; 2 B 2 6 #R&gt; 3 C 3 7 #R&gt; 4 D 4 8   Again, you can imagine a slightly more complicated data frame (here called Z2). #R&gt; id fname lname years variable value #R&gt; 1 A Derek Ogle 25 x 1 #R&gt; 2 A Derek Ogle 25 y 5 #R&gt; 3 B Young Kim 32 x 2 #R&gt; 4 B Young Kim 32 y 6 #R&gt; 5 C Andrew Jensen 6 x 3 #R&gt; 6 C Andrew Jensen 6 y 7 #R&gt; 7 D Jodi Supanich 7 x 4 #R&gt; 8 D Jodi Supanich 7 y 8 The same pivot_wider() on Z2 will again repeat the id, fname, lname, and years variables. V2 &lt;- pivot_wider(Z2,names_from=variable,values_from=value) V2 #R&gt; # A tibble: 4 x 6 #R&gt; id fname lname years x y #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 A Derek Ogle 25 1 5 #R&gt; 2 B Young Kim 32 2 6 #R&gt; 3 C Andrew Jensen 6 3 7 #R&gt; 4 D Jodi Supanich 7 4 8   5.4 Examples with Context 5.4.1 COVID Cases by County and Month In the introduction a simple data frame of COVID cases by month in three Wisconsin counties from January to June 2021 was shown. Here consider a slightly more complicated data frame that contains the same information but from March 2020 to June 2021. This data frame is called covABD_W and is partially shown below. covABD_W #R&gt; # A tibble: 3 x 17 #R&gt; # Groups: County [3] #R&gt; County Mar_2020 Apr_2020 May_2020 Jun_2020 Jul_2020 Aug_2020 Sep_2020 Oct_2020 #R&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 Ashla~ 1 1 0 1 16 16 94 167 #R&gt; 2 Bayfi~ 3 0 0 0 16 26 71 160 #R&gt; 3 Dougl~ 6 3 10 11 93 133 268 316 #R&gt; # ... with 8 more variables: Nov_2020 &lt;dbl&gt;, Dec_2020 &lt;dbl&gt;, Jan_2021 &lt;dbl&gt;, #R&gt; # Feb_2021 &lt;dbl&gt;, Mar_2021 &lt;dbl&gt;, Apr_2021 &lt;dbl&gt;, May_2021 &lt;dbl&gt;, #R&gt; # Jun_2021 &lt;dbl&gt; These data are not tidy because a measurement is COVID cases and they do not appear in one variable/column of this data frame. In addition, an individual is a combination of county and month but month does not appear as a variable. It would be difficult to make a plot of number of cases by month for each county with the data in this format. Thus our goal here is to convert these wider data to longer data in a tidy format. All columns except for County are part of the data to pivot; thus, cols=-County is the easiest way to choose these columns. The variable names in covABD_W are the month and year of the data so I will call the names_to= variable MonYear. Finally, the measurements are of cases of COVID so I will the values_to= variable Cases. Putting this all together gives the following. covABD_L &lt;- pivot_longer(covABD_W,cols=-County,names_to=&quot;MonYear&quot;,values_to=&quot;Cases&quot;) covABD_L #R&gt; # A tibble: 48 x 3 #R&gt; # Groups: County [3] #R&gt; County MonYear Cases #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 Ashland Mar_2020 1 #R&gt; 2 Ashland Apr_2020 1 #R&gt; 3 Ashland May_2020 0 #R&gt; 4 Ashland Jun_2020 1 #R&gt; 5 Ashland Jul_2020 16 #R&gt; 6 Ashland Aug_2020 16 #R&gt; 7 Ashland Sep_2020 94 #R&gt; 8 Ashland Oct_2020 167 #R&gt; 9 Ashland Nov_2020 378 #R&gt; 10 Ashland Dec_2020 331 #R&gt; # ... with 38 more rows This is essentially what I want, but the MonYear variable is going to be problematic because R does not recognize that as a date (note how it is identified as a character class). I would prefer to split those items on the underscore. You can tell pivot_longer() how to split names with names_sep=. However, splitting the month and year will then produce two new columns so names_to= must be a vector of two names for these two new columns. These modifications produce the following result. covABD_L &lt;- pivot_longer(covABD_W,cols=-County, names_to=c(&quot;Month&quot;,&quot;Year&quot;),names_sep=&quot;_&quot;,values_to=&quot;Cases&quot;) covABD_L #R&gt; # A tibble: 48 x 4 #R&gt; # Groups: County [3] #R&gt; County Month Year Cases #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #R&gt; 1 Ashland Mar 2020 1 #R&gt; 2 Ashland Apr 2020 1 #R&gt; 3 Ashland May 2020 0 #R&gt; 4 Ashland Jun 2020 1 #R&gt; 5 Ashland Jul 2020 16 #R&gt; 6 Ashland Aug 2020 16 #R&gt; 7 Ashland Sep 2020 94 #R&gt; 8 Ashland Oct 2020 167 #R&gt; 9 Ashland Nov 2020 378 #R&gt; 10 Ashland Dec 2020 331 #R&gt; # ... with 38 more rows We will need an actual date variable to make a plot of COVID cases over time. The code below does this but uses functions that wont be introduced until Modules XXX and XXX. covABD_L &lt;- covABD_L %&gt;% mutate(Date=lubridate::mdy(paste(Month,&quot;1&quot;,Year,sep=&quot;-&quot;))) covABD_L #R&gt; # A tibble: 48 x 5 #R&gt; # Groups: County [3] #R&gt; County Month Year Cases Date #R&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;date&gt; #R&gt; 1 Ashland Mar 2020 1 2020-03-01 #R&gt; 2 Ashland Apr 2020 1 2020-04-01 #R&gt; 3 Ashland May 2020 0 2020-05-01 #R&gt; 4 Ashland Jun 2020 1 2020-06-01 #R&gt; 5 Ashland Jul 2020 16 2020-07-01 #R&gt; 6 Ashland Aug 2020 16 2020-08-01 #R&gt; 7 Ashland Sep 2020 94 2020-09-01 #R&gt; 8 Ashland Oct 2020 167 2020-10-01 #R&gt; 9 Ashland Nov 2020 378 2020-11-01 #R&gt; 10 Ashland Dec 2020 331 2020-12-01 #R&gt; # ... with 38 more rows Finally, these data can be graphed as shown below.   5.5 Abundance of Mayflies In 1990 technicians for the U.S. Geological Survey recorded the abundance of mayflies (Ephemeroptera) in 10 1 m2 quadrats in Chequamegon Bay. In 2020 they did the same at the same locations. Their data are crecorded in ephem as shown below. ephem #R&gt; # A tibble: 20 x 5 #R&gt; loc hab depth year abundance #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Cobble 14 1990 54 #R&gt; 2 101 Cobble 14 2020 56 #R&gt; 3 102 Cobble 28 1990 55 #R&gt; 4 102 Cobble 28 2020 58 #R&gt; 5 103 Muck 17 1990 51 #R&gt; 6 103 Muck 17 2020 54 #R&gt; 7 104 Sand 10 1990 42 #R&gt; 8 104 Sand 10 2020 50 #R&gt; 9 105 Sand 13 1990 50 #R&gt; 10 105 Sand 13 2020 56 #R&gt; 11 106 Muck 10 1990 57 #R&gt; 12 106 Muck 10 2020 56 #R&gt; 13 107 Muck 15 1990 57 #R&gt; 14 107 Muck 15 2020 44 #R&gt; 15 108 Muck 28 1990 43 #R&gt; 16 108 Muck 28 2020 48 #R&gt; 17 109 Muck 11 1990 42 #R&gt; 18 109 Muck 11 2020 47 #R&gt; 19 110 Sand 25 1990 55 #R&gt; 20 110 Sand 25 2020 40 The researchers want to compute the mean change in abundance across all ten quadrats but that is not easily done with the data in this format. To facilitate this calculation these data need to be converted to a wider format that will have the 1990 and 2020 data in separate columns. In this case, potential names for the variables in the new wider format are in year. The values to be put in those columns are in aboundance. The rest of the variables should be maintained as they identify the individual (i.e., a quadrat). With these definitions these data are converted to a wider format with the following code. ephem2 &lt;- pivot_wider(ephem,names_from=year,values_from=abundance) ephem2 #R&gt; # A tibble: 10 x 5 #R&gt; loc hab depth `1990` `2020` #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Cobble 14 54 56 #R&gt; 2 102 Cobble 28 55 58 #R&gt; 3 103 Muck 17 51 54 #R&gt; 4 104 Sand 10 42 50 #R&gt; 5 105 Sand 13 50 56 #R&gt; 6 106 Muck 10 57 56 #R&gt; 7 107 Muck 15 57 44 #R&gt; 8 108 Muck 28 43 48 #R&gt; 9 109 Muck 11 42 47 #R&gt; 10 110 Sand 25 55 40 This accomplishes the task at hand, but the two new variables are called 1990 and 2020 which are non-standard variable names in R (i.e., they start with numbers). This issue can be avoided by providing a string to be used as a prefix to the names in names_prefix=. ephem2 &lt;- pivot_wider(ephem,names_from=year,names_prefix=&quot;year_&quot;,values_from=abundance) ephem2 #R&gt; # A tibble: 10 x 5 #R&gt; loc hab depth year_1990 year_2020 #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Cobble 14 54 56 #R&gt; 2 102 Cobble 28 55 58 #R&gt; 3 103 Muck 17 51 54 #R&gt; 4 104 Sand 10 42 50 #R&gt; 5 105 Sand 13 50 56 #R&gt; 6 106 Muck 10 57 56 #R&gt; 7 107 Muck 15 57 44 #R&gt; 8 108 Muck 28 43 48 #R&gt; 9 109 Muck 11 42 47 #R&gt; 10 110 Sand 25 55 40 The code below, which will not be introduced until Module XXX, finds the difference in abundance between the two years. ephem2 &lt;- ephem2 %&gt;% mutate(diff90_20=year_1990-year_2020) ephem2 #R&gt; # A tibble: 10 x 6 #R&gt; loc hab depth year_1990 year_2020 diff90_20 #R&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #R&gt; 1 101 Cobble 14 54 56 -2 #R&gt; 2 102 Cobble 28 55 58 -3 #R&gt; 3 103 Muck 17 51 54 -3 #R&gt; 4 104 Sand 10 42 50 -8 #R&gt; 5 105 Sand 13 50 56 -6 #R&gt; 6 106 Muck 10 57 56 1 #R&gt; 7 107 Muck 15 57 44 13 #R&gt; 8 108 Muck 28 43 48 -5 #R&gt; 9 109 Muck 11 42 47 -5 #R&gt; 10 110 Sand 25 55 40 15 These data could then be easily plotted or summarized. Converting and graphing these data will be shown in Section 5.4. There are still other ways (e.g., cols=contains(\"x\")) but these four would be the most common given the names in this data frame. There are other arguments to pivot_longer() for dealing with more complicated naming issues. "],["references.html", "References", " References "]]
